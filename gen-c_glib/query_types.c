/**
 * Autogenerated by Thrift Compiler (0.17.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "query_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *
toString_ValueType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case VALUE_TYPE_VT_INTEGER:return "VALUE_TYPE_VT_INTEGER";
  case VALUE_TYPE_VT_STRING:return "VALUE_TYPE_VT_STRING";
  case VALUE_TYPE_VT_FLOATING:return "VALUE_TYPE_VT_FLOATING";
  case VALUE_TYPE_VT_BOOLEAN:return "VALUE_TYPE_VT_BOOLEAN";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_LinkType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case LINK_TYPE_LT_TO:return "LINK_TYPE_LT_TO";
  case LINK_TYPE_LT_FROM:return "LINK_TYPE_LT_FROM";
  case LINK_TYPE_LT_BOTH:return "LINK_TYPE_LT_BOTH";
  case LINK_TYPE_LT_ANY:return "LINK_TYPE_LT_ANY";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_Comparation(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case COMPARATION_CMP_GT:return "COMPARATION_CMP_GT";
  case COMPARATION_CMP_LT:return "COMPARATION_CMP_LT";
  case COMPARATION_CMP_GE:return "COMPARATION_CMP_GE";
  case COMPARATION_CMP_LE:return "COMPARATION_CMP_LE";
  case COMPARATION_CMP_EQ:return "COMPARATION_CMP_EQ";
  case COMPARATION_CMP_NEQ:return "COMPARATION_CMP_NEQ";
  case COMPARATION_CMP_CONTAINS:return "COMPARATION_CMP_CONTAINS";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_ComparableType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case COMPARABLE_TYPE_CMPT_FIELD:return "COMPARABLE_TYPE_CMPT_FIELD";
  case COMPARABLE_TYPE_CMPT_VALUE:return "COMPARABLE_TYPE_CMPT_VALUE";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_PredicateType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case PREDICATE_TYPE_PT_TERM:return "PREDICATE_TYPE_PT_TERM";
  case PREDICATE_TYPE_PT_OR:return "PREDICATE_TYPE_PT_OR";
  case PREDICATE_TYPE_PT_AND:return "PREDICATE_TYPE_PT_AND";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_QueryType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case QUERY_TYPE_SCHEMA_CREATE:return "QUERY_TYPE_SCHEMA_CREATE";
  case QUERY_TYPE_SCHEMA_GET:return "QUERY_TYPE_SCHEMA_GET";
  case QUERY_TYPE_SCHEMA_GET_ALL:return "QUERY_TYPE_SCHEMA_GET_ALL";
  case QUERY_TYPE_SCHEMA_DELETE:return "QUERY_TYPE_SCHEMA_DELETE";
  case QUERY_TYPE_NODE_CREATE:return "QUERY_TYPE_NODE_CREATE";
  case QUERY_TYPE_NODE_UPDATE:return "QUERY_TYPE_NODE_UPDATE";
  case QUERY_TYPE_NODE_DELETE:return "QUERY_TYPE_NODE_DELETE";
  case QUERY_TYPE_NODE_MATCH:return "QUERY_TYPE_NODE_MATCH";
  case QUERY_TYPE_LINK_CREATE:return "QUERY_TYPE_LINK_CREATE";
  case QUERY_TYPE_LINK_DELETE:return "QUERY_TYPE_LINK_DELETE";
  case QUERY_TYPE_MATCH:return "QUERY_TYPE_MATCH";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_Return(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case RETURN_RETURN_NOTHING:return "RETURN_RETURN_NOTHING";
  case RETURN_RETURN_NODE_FIRST:return "RETURN_RETURN_NODE_FIRST";
  case RETURN_RETURN_NODE_SECOND:return "RETURN_RETURN_NODE_SECOND";
  case RETURN_RETURN_LINK:return "RETURN_RETURN_LINK";
  case RETURN_RETURN_ALL:return "RETURN_RETURN_ALL";
  case RETURN_RETURN_UNDEF:return "RETURN_RETURN_UNDEF";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_QueryResultType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case QUERY_RESULT_TYPE_RESULT_SCHEMA:return "QUERY_RESULT_TYPE_RESULT_SCHEMA";
  case QUERY_RESULT_TYPE_RESULT_GENERATOR:return "QUERY_RESULT_TYPE_RESULT_GENERATOR";
  case QUERY_RESULT_TYPE_RESULT_NONE:return "QUERY_RESULT_TYPE_RESULT_NONE";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

enum _uValueProperties
{
  PROP_U_VALUE_0,
  PROP_U_VALUE_INTEGER,
  PROP_U_VALUE_STRING_,
  PROP_U_VALUE_FLOATING,
  PROP_U_VALUE_BOOLEAN
};

/* reads a u_value object */
static gint32
u_value_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  uValue * this_object = U_VALUE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->integer, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_integer = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->string_ != NULL)
          {
            g_free(this_object->string_);
            this_object->string_ = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->string_, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_string_ = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->floating, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_floating = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->boolean, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_boolean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
u_value_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  uValue * this_object = U_VALUE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "uValue", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_integer == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "integer", T_I32, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->integer, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_string_ == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "string_", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->string_, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_floating == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "floating", T_DOUBLE, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_double (protocol, this_object->floating, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_boolean == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "boolean", T_BOOL, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->boolean, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
u_value_set_property (GObject *object,
                      guint property_id,
                      const GValue *value,
                      GParamSpec *pspec)
{
  uValue *self = U_VALUE (object);

  switch (property_id)
  {
    case PROP_U_VALUE_INTEGER:
      self->integer = g_value_get_int (value);
      self->__isset_integer = TRUE;
      break;

    case PROP_U_VALUE_STRING_:
      if (self->string_ != NULL)
        g_free (self->string_);
      self->string_ = g_value_dup_string (value);
      self->__isset_string_ = TRUE;
      break;

    case PROP_U_VALUE_FLOATING:
      self->floating = g_value_get_double (value);
      self->__isset_floating = TRUE;
      break;

    case PROP_U_VALUE_BOOLEAN:
      self->boolean = g_value_get_boolean (value);
      self->__isset_boolean = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
u_value_get_property (GObject *object,
                      guint property_id,
                      GValue *value,
                      GParamSpec *pspec)
{
  uValue *self = U_VALUE (object);

  switch (property_id)
  {
    case PROP_U_VALUE_INTEGER:
      g_value_set_int (value, self->integer);
      break;

    case PROP_U_VALUE_STRING_:
      g_value_set_string (value, self->string_);
      break;

    case PROP_U_VALUE_FLOATING:
      g_value_set_double (value, self->floating);
      break;

    case PROP_U_VALUE_BOOLEAN:
      g_value_set_boolean (value, self->boolean);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
u_value_instance_init (uValue * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->integer = 0;
  object->__isset_integer = FALSE;
  object->string_ = NULL;
  object->__isset_string_ = FALSE;
  object->floating = 0;
  object->__isset_floating = FALSE;
  object->boolean = 0;
  object->__isset_boolean = FALSE;
}

static void 
u_value_finalize (GObject *object)
{
  uValue *tobject = U_VALUE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->string_ != NULL)
  {
    g_free(tobject->string_);
    tobject->string_ = NULL;
  }
}

static void
u_value_class_init (uValueClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = u_value_read;
  struct_class->write = u_value_write;

  gobject_class->finalize = u_value_finalize;
  gobject_class->get_property = u_value_get_property;
  gobject_class->set_property = u_value_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_U_VALUE_INTEGER,
     g_param_spec_int ("integer",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_U_VALUE_STRING_,
     g_param_spec_string ("string_",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_U_VALUE_FLOATING,
     g_param_spec_double ("floating",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_U_VALUE_BOOLEAN,
     g_param_spec_boolean ("boolean",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
u_value_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (uValueClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) u_value_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (uValue),
      0, /* n_preallocs */
      (GInstanceInitFunc) u_value_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "uValueType",
                                   &type_info, 0);
  }

  return type;
}

enum _ValueProperties
{
  PROP_VALUE_0,
  PROP_VALUE_TYPE,
  PROP_VALUE_VALUE
};

/* reads a value object */
static gint32
value_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Value * this_object = VALUE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast0;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast0, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (ValueType)ecast0;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
value_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Value * this_object = VALUE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Value", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
value_set_property (GObject *object,
                    guint property_id,
                    const GValue *value,
                    GParamSpec *pspec)
{
  Value *self = VALUE (object);

  switch (property_id)
  {
    case PROP_VALUE_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_VALUE_VALUE:
      if (self->value != NULL)
        g_object_unref (self->value);
      self->value = g_value_dup_object (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
value_get_property (GObject *object,
                    guint property_id,
                    GValue *value,
                    GParamSpec *pspec)
{
  Value *self = VALUE (object);

  switch (property_id)
  {
    case PROP_VALUE_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_VALUE_VALUE:
      g_value_set_object (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
value_instance_init (Value * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->value = g_object_new (TYPE_U_VALUE, NULL);
  object->__isset_value = FALSE;
}

static void 
value_finalize (GObject *object)
{
  Value *tobject = VALUE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->value != NULL)
  {
    g_object_unref(tobject->value);
    tobject->value = NULL;
  }
}

static void
value_class_init (ValueClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = value_read;
  struct_class->write = value_write;

  gobject_class->finalize = value_finalize;
  gobject_class->get_property = value_get_property;
  gobject_class->set_property = value_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_VALUE_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_VALUE_VALUE,
     g_param_spec_object ("value",
                         NULL,
                         NULL,
                         TYPE_U_VALUE,
                         G_PARAM_READWRITE));
}

GType
value_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ValueClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) value_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Value),
      0, /* n_preallocs */
      (GInstanceInitFunc) value_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ValueType",
                                   &type_info, 0);
  }

  return type;
}

enum _PropertyProperties
{
  PROP_PROPERTY_0,
  PROP_PROPERTY_FIELD,
  PROP_PROPERTY_VALUE
};

/* reads a property object */
static gint32
property_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Property * this_object = PROPERTY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->field != NULL)
          {
            g_free(this_object->field);
            this_object->field = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->field, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
property_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Property * this_object = PROPERTY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Property", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "field", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->field, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
property_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  Property *self = PROPERTY (object);

  switch (property_id)
  {
    case PROP_PROPERTY_FIELD:
      if (self->field != NULL)
        g_free (self->field);
      self->field = g_value_dup_string (value);
      self->__isset_field = TRUE;
      break;

    case PROP_PROPERTY_VALUE:
      if (self->value != NULL)
        g_object_unref (self->value);
      self->value = g_value_dup_object (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
property_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  Property *self = PROPERTY (object);

  switch (property_id)
  {
    case PROP_PROPERTY_FIELD:
      g_value_set_string (value, self->field);
      break;

    case PROP_PROPERTY_VALUE:
      g_value_set_object (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
property_instance_init (Property * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->field = NULL;
  object->__isset_field = FALSE;
  object->value = g_object_new (TYPE_VALUE, NULL);
  object->__isset_value = FALSE;
}

static void 
property_finalize (GObject *object)
{
  Property *tobject = PROPERTY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->field != NULL)
  {
    g_free(tobject->field);
    tobject->field = NULL;
  }
  if (tobject->value != NULL)
  {
    g_object_unref(tobject->value);
    tobject->value = NULL;
  }
}

static void
property_class_init (PropertyClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = property_read;
  struct_class->write = property_write;

  gobject_class->finalize = property_finalize;
  gobject_class->get_property = property_get_property;
  gobject_class->set_property = property_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROPERTY_FIELD,
     g_param_spec_string ("field",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROPERTY_VALUE,
     g_param_spec_object ("value",
                         NULL,
                         NULL,
                         TYPE_VALUE,
                         G_PARAM_READWRITE));
}

GType
property_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (PropertyClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) property_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Property),
      0, /* n_preallocs */
      (GInstanceInitFunc) property_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "PropertyType",
                                   &type_info, 0);
  }

  return type;
}

enum _AttributeProperties
{
  PROP_ATTRIBUTE_0,
  PROP_ATTRIBUTE_NAME,
  PROP_ATTRIBUTE_VT
};

/* reads a attribute object */
static gint32
attribute_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Attribute * this_object = ATTRIBUTE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast1;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast1, error)) < 0)
            return -1;
          xfer += ret;
          this_object->vt = (ValueType)ecast1;
          this_object->__isset_vt = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
attribute_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Attribute * this_object = ATTRIBUTE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Attribute", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "vt", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->vt, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
attribute_set_property (GObject *object,
                        guint property_id,
                        const GValue *value,
                        GParamSpec *pspec)
{
  Attribute *self = ATTRIBUTE (object);

  switch (property_id)
  {
    case PROP_ATTRIBUTE_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_ATTRIBUTE_VT:
      self->vt = g_value_get_int (value);
      self->__isset_vt = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
attribute_get_property (GObject *object,
                        guint property_id,
                        GValue *value,
                        GParamSpec *pspec)
{
  Attribute *self = ATTRIBUTE (object);

  switch (property_id)
  {
    case PROP_ATTRIBUTE_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_ATTRIBUTE_VT:
      g_value_set_int (value, self->vt);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
attribute_instance_init (Attribute * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
  object->__isset_vt = FALSE;
}

static void 
attribute_finalize (GObject *object)
{
  Attribute *tobject = ATTRIBUTE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
}

static void
attribute_class_init (AttributeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = attribute_read;
  struct_class->write = attribute_write;

  gobject_class->finalize = attribute_finalize;
  gobject_class->get_property = attribute_get_property;
  gobject_class->set_property = attribute_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_ATTRIBUTE_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ATTRIBUTE_VT,
     g_param_spec_int ("vt",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));
}

GType
attribute_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (AttributeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) attribute_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Attribute),
      0, /* n_preallocs */
      (GInstanceInitFunc) attribute_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "AttributeType",
                                   &type_info, 0);
  }

  return type;
}

enum _SchemaProperties
{
  PROP_SCHEMA_0,
  PROP_SCHEMA_NAME,
  PROP_SCHEMA_ATTRIBUTES
};

/* reads a schema object */
static gint32
schema_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Schema * this_object = SCHEMA(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Attribute * _elem2 = NULL;
              if ( _elem2 != NULL)
              {
                g_object_unref (_elem2);
              }
              _elem2 = g_object_new (TYPE_ATTRIBUTE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem2), protocol, error)) < 0)
              {
                g_object_unref (_elem2);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->attributes, _elem2);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
schema_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Schema * this_object = SCHEMA(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Schema", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i3;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->attributes ? this_object->attributes->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i3 = 0; i3 < (this_object->attributes ? this_object->attributes->len : 0); i3++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->attributes, i3))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
schema_set_property (GObject *object,
                     guint property_id,
                     const GValue *value,
                     GParamSpec *pspec)
{
  Schema *self = SCHEMA (object);

  switch (property_id)
  {
    case PROP_SCHEMA_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_SCHEMA_ATTRIBUTES:
      if (self->attributes != NULL)
        g_ptr_array_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
schema_get_property (GObject *object,
                     guint property_id,
                     GValue *value,
                     GParamSpec *pspec)
{
  Schema *self = SCHEMA (object);

  switch (property_id)
  {
    case PROP_SCHEMA_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_SCHEMA_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
schema_instance_init (Schema * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
  object->attributes = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_attributes = FALSE;
}

static void 
schema_finalize (GObject *object)
{
  Schema *tobject = SCHEMA (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_ptr_array_unref (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
schema_class_init (SchemaClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = schema_read;
  struct_class->write = schema_write;

  gobject_class->finalize = schema_finalize;
  gobject_class->get_property = schema_get_property;
  gobject_class->set_property = schema_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
schema_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SchemaClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) schema_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Schema),
      0, /* n_preallocs */
      (GInstanceInitFunc) schema_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SchemaType",
                                   &type_info, 0);
  }

  return type;
}

enum _NodeProperties
{
  PROP_NODE_0,
  PROP_NODE_NAME,
  PROP_NODE_PROPERTIES
};

/* reads a node object */
static gint32
node_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Node * this_object = NODE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Property * _elem4 = NULL;
              if ( _elem4 != NULL)
              {
                g_object_unref (_elem4);
              }
              _elem4 = g_object_new (TYPE_PROPERTY, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem4), protocol, error)) < 0)
              {
                g_object_unref (_elem4);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->properties, _elem4);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_properties = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
node_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Node * this_object = NODE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Node", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "properties", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i5;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->properties ? this_object->properties->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i5 = 0; i5 < (this_object->properties ? this_object->properties->len : 0); i5++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->properties, i5))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
node_set_property (GObject *object,
                   guint property_id,
                   const GValue *value,
                   GParamSpec *pspec)
{
  Node *self = NODE (object);

  switch (property_id)
  {
    case PROP_NODE_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_NODE_PROPERTIES:
      if (self->properties != NULL)
        g_ptr_array_unref (self->properties);
      self->properties = g_value_dup_boxed (value);
      self->__isset_properties = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
node_get_property (GObject *object,
                   guint property_id,
                   GValue *value,
                   GParamSpec *pspec)
{
  Node *self = NODE (object);

  switch (property_id)
  {
    case PROP_NODE_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_NODE_PROPERTIES:
      g_value_set_boxed (value, self->properties);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
node_instance_init (Node * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
  object->properties = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_properties = FALSE;
}

static void 
node_finalize (GObject *object)
{
  Node *tobject = NODE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->properties != NULL)
  {
    g_ptr_array_unref (tobject->properties);
    tobject->properties = NULL;
  }
}

static void
node_class_init (NodeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = node_read;
  struct_class->write = node_write;

  gobject_class->finalize = node_finalize;
  gobject_class->get_property = node_get_property;
  gobject_class->set_property = node_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NODE_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NODE_PROPERTIES,
     g_param_spec_boxed ("properties",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
node_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NodeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) node_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Node),
      0, /* n_preallocs */
      (GInstanceInitFunc) node_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NodeType",
                                   &type_info, 0);
  }

  return type;
}

enum _LinkProperties
{
  PROP_LINK_0,
  PROP_LINK_NAME,
  PROP_LINK_TYPE,
  PROP_LINK_FIRST,
  PROP_LINK_SECOND
};

/* reads a link object */
static gint32
link_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Link * this_object = LINK(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast6;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast6, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (LinkType)ecast6;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->first != NULL)
          {
            g_free(this_object->first);
            this_object->first = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->first, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_first = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->second != NULL)
          {
            g_free(this_object->second);
            this_object->second = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->second, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_second = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
link_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Link * this_object = LINK(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Link", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "first", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->first, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "second", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->second, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
link_set_property (GObject *object,
                   guint property_id,
                   const GValue *value,
                   GParamSpec *pspec)
{
  Link *self = LINK (object);

  switch (property_id)
  {
    case PROP_LINK_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_LINK_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_LINK_FIRST:
      if (self->first != NULL)
        g_free (self->first);
      self->first = g_value_dup_string (value);
      self->__isset_first = TRUE;
      break;

    case PROP_LINK_SECOND:
      if (self->second != NULL)
        g_free (self->second);
      self->second = g_value_dup_string (value);
      self->__isset_second = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
link_get_property (GObject *object,
                   guint property_id,
                   GValue *value,
                   GParamSpec *pspec)
{
  Link *self = LINK (object);

  switch (property_id)
  {
    case PROP_LINK_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_LINK_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_LINK_FIRST:
      g_value_set_string (value, self->first);
      break;

    case PROP_LINK_SECOND:
      g_value_set_string (value, self->second);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
link_instance_init (Link * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
  object->__isset_type = FALSE;
  object->first = NULL;
  object->__isset_first = FALSE;
  object->second = NULL;
  object->__isset_second = FALSE;
}

static void 
link_finalize (GObject *object)
{
  Link *tobject = LINK (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->first != NULL)
  {
    g_free(tobject->first);
    tobject->first = NULL;
  }
  if (tobject->second != NULL)
  {
    g_free(tobject->second);
    tobject->second = NULL;
  }
}

static void
link_class_init (LinkClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = link_read;
  struct_class->write = link_write;

  gobject_class->finalize = link_finalize;
  gobject_class->get_property = link_get_property;
  gobject_class->set_property = link_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_LINK_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LINK_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LINK_FIRST,
     g_param_spec_string ("first",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LINK_SECOND,
     g_param_spec_string ("second",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
link_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (LinkClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) link_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Link),
      0, /* n_preallocs */
      (GInstanceInitFunc) link_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "LinkType",
                                   &type_info, 0);
  }

  return type;
}

enum _uComparableProperties
{
  PROP_U_COMPARABLE_0,
  PROP_U_COMPARABLE_FIELD_NAME,
  PROP_U_COMPARABLE_VALUE
};

/* reads a u_comparable object */
static gint32
u_comparable_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  uComparable * this_object = U_COMPARABLE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->field_name != NULL)
          {
            g_free(this_object->field_name);
            this_object->field_name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->field_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
u_comparable_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  uComparable * this_object = U_COMPARABLE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "uComparable", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_field_name == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field_name", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->field_name, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_value == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
u_comparable_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  uComparable *self = U_COMPARABLE (object);

  switch (property_id)
  {
    case PROP_U_COMPARABLE_FIELD_NAME:
      if (self->field_name != NULL)
        g_free (self->field_name);
      self->field_name = g_value_dup_string (value);
      self->__isset_field_name = TRUE;
      break;

    case PROP_U_COMPARABLE_VALUE:
      if (self->value != NULL)
        g_object_unref (self->value);
      self->value = g_value_dup_object (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
u_comparable_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  uComparable *self = U_COMPARABLE (object);

  switch (property_id)
  {
    case PROP_U_COMPARABLE_FIELD_NAME:
      g_value_set_string (value, self->field_name);
      break;

    case PROP_U_COMPARABLE_VALUE:
      g_value_set_object (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
u_comparable_instance_init (uComparable * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->field_name = NULL;
  object->__isset_field_name = FALSE;
  object->value = g_object_new (TYPE_VALUE, NULL);
  object->__isset_value = FALSE;
}

static void 
u_comparable_finalize (GObject *object)
{
  uComparable *tobject = U_COMPARABLE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->field_name != NULL)
  {
    g_free(tobject->field_name);
    tobject->field_name = NULL;
  }
  if (tobject->value != NULL)
  {
    g_object_unref(tobject->value);
    tobject->value = NULL;
  }
}

static void
u_comparable_class_init (uComparableClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = u_comparable_read;
  struct_class->write = u_comparable_write;

  gobject_class->finalize = u_comparable_finalize;
  gobject_class->get_property = u_comparable_get_property;
  gobject_class->set_property = u_comparable_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_U_COMPARABLE_FIELD_NAME,
     g_param_spec_string ("field_name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_U_COMPARABLE_VALUE,
     g_param_spec_object ("value",
                         NULL,
                         NULL,
                         TYPE_VALUE,
                         G_PARAM_READWRITE));
}

GType
u_comparable_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (uComparableClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) u_comparable_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (uComparable),
      0, /* n_preallocs */
      (GInstanceInitFunc) u_comparable_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "uComparableType",
                                   &type_info, 0);
  }

  return type;
}

enum _ComparableProperties
{
  PROP_COMPARABLE_0,
  PROP_COMPARABLE_TYPE,
  PROP_COMPARABLE_COMPARABLE
};

/* reads a comparable object */
static gint32
comparable_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Comparable * this_object = COMPARABLE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast7;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast7, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (ComparableType)ecast7;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->comparable), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_comparable = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
comparable_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Comparable * this_object = COMPARABLE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Comparable", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "comparable", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->comparable), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
comparable_set_property (GObject *object,
                         guint property_id,
                         const GValue *value,
                         GParamSpec *pspec)
{
  Comparable *self = COMPARABLE (object);

  switch (property_id)
  {
    case PROP_COMPARABLE_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_COMPARABLE_COMPARABLE:
      if (self->comparable != NULL)
        g_object_unref (self->comparable);
      self->comparable = g_value_dup_object (value);
      self->__isset_comparable = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
comparable_get_property (GObject *object,
                         guint property_id,
                         GValue *value,
                         GParamSpec *pspec)
{
  Comparable *self = COMPARABLE (object);

  switch (property_id)
  {
    case PROP_COMPARABLE_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_COMPARABLE_COMPARABLE:
      g_value_set_object (value, self->comparable);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
comparable_instance_init (Comparable * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->comparable = g_object_new (TYPE_U_COMPARABLE, NULL);
  object->__isset_comparable = FALSE;
}

static void 
comparable_finalize (GObject *object)
{
  Comparable *tobject = COMPARABLE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->comparable != NULL)
  {
    g_object_unref(tobject->comparable);
    tobject->comparable = NULL;
  }
}

static void
comparable_class_init (ComparableClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = comparable_read;
  struct_class->write = comparable_write;

  gobject_class->finalize = comparable_finalize;
  gobject_class->get_property = comparable_get_property;
  gobject_class->set_property = comparable_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_COMPARABLE_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       1,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COMPARABLE_COMPARABLE,
     g_param_spec_object ("comparable",
                         NULL,
                         NULL,
                         TYPE_U_COMPARABLE,
                         G_PARAM_READWRITE));
}

GType
comparable_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ComparableClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) comparable_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Comparable),
      0, /* n_preallocs */
      (GInstanceInitFunc) comparable_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ComparableType",
                                   &type_info, 0);
  }

  return type;
}

enum _CompareProperties
{
  PROP_COMPARE_0,
  PROP_COMPARE_CMP,
  PROP_COMPARE_WITH_
};

/* reads a compare object */
static gint32
compare_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Compare * this_object = COMPARE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast8;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast8, error)) < 0)
            return -1;
          xfer += ret;
          this_object->cmp = (Comparation)ecast8;
          this_object->__isset_cmp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->with_), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_with_ = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
compare_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Compare * this_object = COMPARE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Compare", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cmp", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->cmp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "with_", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->with_), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
compare_set_property (GObject *object,
                      guint property_id,
                      const GValue *value,
                      GParamSpec *pspec)
{
  Compare *self = COMPARE (object);

  switch (property_id)
  {
    case PROP_COMPARE_CMP:
      self->cmp = g_value_get_int (value);
      self->__isset_cmp = TRUE;
      break;

    case PROP_COMPARE_WITH_:
      if (self->with_ != NULL)
        g_object_unref (self->with_);
      self->with_ = g_value_dup_object (value);
      self->__isset_with_ = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
compare_get_property (GObject *object,
                      guint property_id,
                      GValue *value,
                      GParamSpec *pspec)
{
  Compare *self = COMPARE (object);

  switch (property_id)
  {
    case PROP_COMPARE_CMP:
      g_value_set_int (value, self->cmp);
      break;

    case PROP_COMPARE_WITH_:
      g_value_set_object (value, self->with_);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
compare_instance_init (Compare * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_cmp = FALSE;
  object->with_ = g_object_new (TYPE_COMPARABLE, NULL);
  object->__isset_with_ = FALSE;
}

static void 
compare_finalize (GObject *object)
{
  Compare *tobject = COMPARE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->with_ != NULL)
  {
    g_object_unref(tobject->with_);
    tobject->with_ = NULL;
  }
}

static void
compare_class_init (CompareClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = compare_read;
  struct_class->write = compare_write;

  gobject_class->finalize = compare_finalize;
  gobject_class->get_property = compare_get_property;
  gobject_class->set_property = compare_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_COMPARE_CMP,
     g_param_spec_int ("cmp",
                       NULL,
                       NULL,
                       0,
                       6,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COMPARE_WITH_,
     g_param_spec_object ("with_",
                         NULL,
                         NULL,
                         TYPE_COMPARABLE,
                         G_PARAM_READWRITE));
}

GType
compare_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CompareClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) compare_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Compare),
      0, /* n_preallocs */
      (GInstanceInitFunc) compare_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CompareType",
                                   &type_info, 0);
  }

  return type;
}

enum _ConditionCompareProperties
{
  PROP_CONDITION_COMPARE_0,
  PROP_CONDITION_COMPARE_LEFT,
  PROP_CONDITION_COMPARE_COMPARE
};

/* reads a condition_compare object */
static gint32
condition_compare_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ConditionCompare * this_object = CONDITION_COMPARE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->left), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_left = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->compare), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_compare = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
condition_compare_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ConditionCompare * this_object = CONDITION_COMPARE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ConditionCompare", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "left", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->left), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "compare", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->compare), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
condition_compare_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  ConditionCompare *self = CONDITION_COMPARE (object);

  switch (property_id)
  {
    case PROP_CONDITION_COMPARE_LEFT:
      if (self->left != NULL)
        g_object_unref (self->left);
      self->left = g_value_dup_object (value);
      self->__isset_left = TRUE;
      break;

    case PROP_CONDITION_COMPARE_COMPARE:
      if (self->compare != NULL)
        g_object_unref (self->compare);
      self->compare = g_value_dup_object (value);
      self->__isset_compare = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
condition_compare_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  ConditionCompare *self = CONDITION_COMPARE (object);

  switch (property_id)
  {
    case PROP_CONDITION_COMPARE_LEFT:
      g_value_set_object (value, self->left);
      break;

    case PROP_CONDITION_COMPARE_COMPARE:
      g_value_set_object (value, self->compare);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
condition_compare_instance_init (ConditionCompare * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->left = g_object_new (TYPE_COMPARABLE, NULL);
  object->__isset_left = FALSE;
  object->compare = g_object_new (TYPE_COMPARE, NULL);
  object->__isset_compare = FALSE;
}

static void 
condition_compare_finalize (GObject *object)
{
  ConditionCompare *tobject = CONDITION_COMPARE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->left != NULL)
  {
    g_object_unref(tobject->left);
    tobject->left = NULL;
  }
  if (tobject->compare != NULL)
  {
    g_object_unref(tobject->compare);
    tobject->compare = NULL;
  }
}

static void
condition_compare_class_init (ConditionCompareClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = condition_compare_read;
  struct_class->write = condition_compare_write;

  gobject_class->finalize = condition_compare_finalize;
  gobject_class->get_property = condition_compare_get_property;
  gobject_class->set_property = condition_compare_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CONDITION_COMPARE_LEFT,
     g_param_spec_object ("left",
                         NULL,
                         NULL,
                         TYPE_COMPARABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CONDITION_COMPARE_COMPARE,
     g_param_spec_object ("compare",
                         NULL,
                         NULL,
                         TYPE_COMPARE,
                         G_PARAM_READWRITE));
}

GType
condition_compare_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ConditionCompareClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) condition_compare_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ConditionCompare),
      0, /* n_preallocs */
      (GInstanceInitFunc) condition_compare_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ConditionCompareType",
                                   &type_info, 0);
  }

  return type;
}

enum _uPredicateProperties
{
  PROP_U_PREDICATE_0,
  PROP_U_PREDICATE_TERM,
  PROP_U_PREDICATE_AND_,
  PROP_U_PREDICATE_OR_
};

/* reads a u_predicate object */
static gint32
u_predicate_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  uPredicate * this_object = U_PREDICATE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->term), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_term = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Predicate * _elem9 = NULL;
              if ( _elem9 != NULL)
              {
                g_object_unref (_elem9);
              }
              _elem9 = g_object_new (TYPE_PREDICATE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem9), protocol, error)) < 0)
              {
                g_object_unref (_elem9);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->and_, _elem9);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_and_ = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Predicate * _elem10 = NULL;
              if ( _elem10 != NULL)
              {
                g_object_unref (_elem10);
              }
              _elem10 = g_object_new (TYPE_PREDICATE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem10), protocol, error)) < 0)
              {
                g_object_unref (_elem10);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->or_, _elem10);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_or_ = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
u_predicate_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  uPredicate * this_object = U_PREDICATE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "uPredicate", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_term == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "term", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->term), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_and_ == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "and_", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i11;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->and_ ? this_object->and_->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i11 = 0; i11 < (this_object->and_ ? this_object->and_->len : 0); i11++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->and_, i11))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_or_ == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "or_", T_LIST, 3, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i12;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->or_ ? this_object->or_->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i12 = 0; i12 < (this_object->or_ ? this_object->or_->len : 0); i12++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->or_, i12))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
u_predicate_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  uPredicate *self = U_PREDICATE (object);

  switch (property_id)
  {
    case PROP_U_PREDICATE_TERM:
      if (self->term != NULL)
        g_object_unref (self->term);
      self->term = g_value_dup_object (value);
      self->__isset_term = TRUE;
      break;

    case PROP_U_PREDICATE_AND_:
      if (self->and_ != NULL)
        g_ptr_array_unref (self->and_);
      self->and_ = g_value_dup_boxed (value);
      self->__isset_and_ = TRUE;
      break;

    case PROP_U_PREDICATE_OR_:
      if (self->or_ != NULL)
        g_ptr_array_unref (self->or_);
      self->or_ = g_value_dup_boxed (value);
      self->__isset_or_ = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
u_predicate_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  uPredicate *self = U_PREDICATE (object);

  switch (property_id)
  {
    case PROP_U_PREDICATE_TERM:
      g_value_set_object (value, self->term);
      break;

    case PROP_U_PREDICATE_AND_:
      g_value_set_boxed (value, self->and_);
      break;

    case PROP_U_PREDICATE_OR_:
      g_value_set_boxed (value, self->or_);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
u_predicate_instance_init (uPredicate * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->term = g_object_new (TYPE_CONDITION_COMPARE, NULL);
  object->__isset_term = FALSE;
  object->and_ = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_and_ = FALSE;
  object->or_ = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_or_ = FALSE;
}

static void 
u_predicate_finalize (GObject *object)
{
  uPredicate *tobject = U_PREDICATE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->term != NULL)
  {
    g_object_unref(tobject->term);
    tobject->term = NULL;
  }
  if (tobject->and_ != NULL)
  {
    g_ptr_array_unref (tobject->and_);
    tobject->and_ = NULL;
  }
  if (tobject->or_ != NULL)
  {
    g_ptr_array_unref (tobject->or_);
    tobject->or_ = NULL;
  }
}

static void
u_predicate_class_init (uPredicateClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = u_predicate_read;
  struct_class->write = u_predicate_write;

  gobject_class->finalize = u_predicate_finalize;
  gobject_class->get_property = u_predicate_get_property;
  gobject_class->set_property = u_predicate_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_U_PREDICATE_TERM,
     g_param_spec_object ("term",
                         NULL,
                         NULL,
                         TYPE_CONDITION_COMPARE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_U_PREDICATE_AND_,
     g_param_spec_boxed ("and_",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_U_PREDICATE_OR_,
     g_param_spec_boxed ("or_",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
u_predicate_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (uPredicateClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) u_predicate_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (uPredicate),
      0, /* n_preallocs */
      (GInstanceInitFunc) u_predicate_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "uPredicateType",
                                   &type_info, 0);
  }

  return type;
}

enum _PredicateProperties
{
  PROP_PREDICATE_0,
  PROP_PREDICATE_TYPE,
  PROP_PREDICATE_PREDICATE
};

/* reads a predicate object */
static gint32
predicate_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Predicate * this_object = PREDICATE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast13;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast13, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (PredicateType)ecast13;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->predicate), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_predicate = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
predicate_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Predicate * this_object = PREDICATE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Predicate", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "predicate", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->predicate), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
predicate_set_property (GObject *object,
                        guint property_id,
                        const GValue *value,
                        GParamSpec *pspec)
{
  Predicate *self = PREDICATE (object);

  switch (property_id)
  {
    case PROP_PREDICATE_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_PREDICATE_PREDICATE:
      if (self->predicate != NULL)
        g_object_unref (self->predicate);
      self->predicate = g_value_dup_object (value);
      self->__isset_predicate = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
predicate_get_property (GObject *object,
                        guint property_id,
                        GValue *value,
                        GParamSpec *pspec)
{
  Predicate *self = PREDICATE (object);

  switch (property_id)
  {
    case PROP_PREDICATE_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_PREDICATE_PREDICATE:
      g_value_set_object (value, self->predicate);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
predicate_instance_init (Predicate * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->predicate = g_object_new (TYPE_U_PREDICATE, NULL);
  object->__isset_predicate = FALSE;
}

static void 
predicate_finalize (GObject *object)
{
  Predicate *tobject = PREDICATE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->predicate != NULL)
  {
    g_object_unref(tobject->predicate);
    tobject->predicate = NULL;
  }
}

static void
predicate_class_init (PredicateClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = predicate_read;
  struct_class->write = predicate_write;

  gobject_class->finalize = predicate_finalize;
  gobject_class->get_property = predicate_get_property;
  gobject_class->set_property = predicate_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PREDICATE_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       2,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PREDICATE_PREDICATE,
     g_param_spec_object ("predicate",
                         NULL,
                         NULL,
                         TYPE_U_PREDICATE,
                         G_PARAM_READWRITE));
}

GType
predicate_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (PredicateClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) predicate_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Predicate),
      0, /* n_preallocs */
      (GInstanceInitFunc) predicate_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "PredicateType",
                                   &type_info, 0);
  }

  return type;
}

enum _NodeConditionProperties
{
  PROP_NODE_CONDITION_0,
  PROP_NODE_CONDITION_IS_NULL,
  PROP_NODE_CONDITION_SCHEMA,
  PROP_NODE_CONDITION_PREDICATES
};

/* reads a node_condition object */
static gint32
node_condition_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NodeCondition * this_object = NODE_CONDITION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->is_null, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_is_null = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->schema != NULL)
          {
            g_free(this_object->schema);
            this_object->schema = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->schema, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_schema = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Predicate * _elem14 = NULL;
              if ( _elem14 != NULL)
              {
                g_object_unref (_elem14);
              }
              _elem14 = g_object_new (TYPE_PREDICATE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem14), protocol, error)) < 0)
              {
                g_object_unref (_elem14);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->predicates, _elem14);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_predicates = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
node_condition_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NodeCondition * this_object = NODE_CONDITION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NodeCondition", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "is_null", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->is_null, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "schema", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->schema, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "predicates", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i15;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->predicates ? this_object->predicates->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i15 = 0; i15 < (this_object->predicates ? this_object->predicates->len : 0); i15++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->predicates, i15))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
node_condition_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  NodeCondition *self = NODE_CONDITION (object);

  switch (property_id)
  {
    case PROP_NODE_CONDITION_IS_NULL:
      self->is_null = g_value_get_boolean (value);
      self->__isset_is_null = TRUE;
      break;

    case PROP_NODE_CONDITION_SCHEMA:
      if (self->schema != NULL)
        g_free (self->schema);
      self->schema = g_value_dup_string (value);
      self->__isset_schema = TRUE;
      break;

    case PROP_NODE_CONDITION_PREDICATES:
      if (self->predicates != NULL)
        g_ptr_array_unref (self->predicates);
      self->predicates = g_value_dup_boxed (value);
      self->__isset_predicates = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
node_condition_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  NodeCondition *self = NODE_CONDITION (object);

  switch (property_id)
  {
    case PROP_NODE_CONDITION_IS_NULL:
      g_value_set_boolean (value, self->is_null);
      break;

    case PROP_NODE_CONDITION_SCHEMA:
      g_value_set_string (value, self->schema);
      break;

    case PROP_NODE_CONDITION_PREDICATES:
      g_value_set_boxed (value, self->predicates);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
node_condition_instance_init (NodeCondition * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->is_null = 0;
  object->__isset_is_null = FALSE;
  object->schema = NULL;
  object->__isset_schema = FALSE;
  object->predicates = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_predicates = FALSE;
}

static void 
node_condition_finalize (GObject *object)
{
  NodeCondition *tobject = NODE_CONDITION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->schema != NULL)
  {
    g_free(tobject->schema);
    tobject->schema = NULL;
  }
  if (tobject->predicates != NULL)
  {
    g_ptr_array_unref (tobject->predicates);
    tobject->predicates = NULL;
  }
}

static void
node_condition_class_init (NodeConditionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = node_condition_read;
  struct_class->write = node_condition_write;

  gobject_class->finalize = node_condition_finalize;
  gobject_class->get_property = node_condition_get_property;
  gobject_class->set_property = node_condition_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NODE_CONDITION_IS_NULL,
     g_param_spec_boolean ("is_null",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NODE_CONDITION_SCHEMA,
     g_param_spec_string ("schema",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NODE_CONDITION_PREDICATES,
     g_param_spec_boxed ("predicates",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
node_condition_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NodeConditionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) node_condition_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NodeCondition),
      0, /* n_preallocs */
      (GInstanceInitFunc) node_condition_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NodeConditionType",
                                   &type_info, 0);
  }

  return type;
}

enum _LinkConditionProperties
{
  PROP_LINK_CONDITION_0,
  PROP_LINK_CONDITION_IS_NULL,
  PROP_LINK_CONDITION_LINK_TYPE,
  PROP_LINK_CONDITION_LINK_NAME
};

/* reads a link_condition object */
static gint32
link_condition_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  LinkCondition * this_object = LINK_CONDITION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->is_null, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_is_null = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast16;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast16, error)) < 0)
            return -1;
          xfer += ret;
          this_object->link_type = (LinkType)ecast16;
          this_object->__isset_link_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->link_name != NULL)
          {
            g_free(this_object->link_name);
            this_object->link_name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->link_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_link_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
link_condition_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  LinkCondition * this_object = LINK_CONDITION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "LinkCondition", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "is_null", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->is_null, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "link_type", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->link_type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "link_name", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->link_name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
link_condition_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  LinkCondition *self = LINK_CONDITION (object);

  switch (property_id)
  {
    case PROP_LINK_CONDITION_IS_NULL:
      self->is_null = g_value_get_boolean (value);
      self->__isset_is_null = TRUE;
      break;

    case PROP_LINK_CONDITION_LINK_TYPE:
      self->link_type = g_value_get_int (value);
      self->__isset_link_type = TRUE;
      break;

    case PROP_LINK_CONDITION_LINK_NAME:
      if (self->link_name != NULL)
        g_free (self->link_name);
      self->link_name = g_value_dup_string (value);
      self->__isset_link_name = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
link_condition_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  LinkCondition *self = LINK_CONDITION (object);

  switch (property_id)
  {
    case PROP_LINK_CONDITION_IS_NULL:
      g_value_set_boolean (value, self->is_null);
      break;

    case PROP_LINK_CONDITION_LINK_TYPE:
      g_value_set_int (value, self->link_type);
      break;

    case PROP_LINK_CONDITION_LINK_NAME:
      g_value_set_string (value, self->link_name);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
link_condition_instance_init (LinkCondition * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->is_null = 0;
  object->__isset_is_null = FALSE;
  object->__isset_link_type = FALSE;
  object->link_name = NULL;
  object->__isset_link_name = FALSE;
}

static void 
link_condition_finalize (GObject *object)
{
  LinkCondition *tobject = LINK_CONDITION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->link_name != NULL)
  {
    g_free(tobject->link_name);
    tobject->link_name = NULL;
  }
}

static void
link_condition_class_init (LinkConditionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = link_condition_read;
  struct_class->write = link_condition_write;

  gobject_class->finalize = link_condition_finalize;
  gobject_class->get_property = link_condition_get_property;
  gobject_class->set_property = link_condition_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_LINK_CONDITION_IS_NULL,
     g_param_spec_boolean ("is_null",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LINK_CONDITION_LINK_TYPE,
     g_param_spec_int ("link_type",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LINK_CONDITION_LINK_NAME,
     g_param_spec_string ("link_name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
link_condition_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (LinkConditionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) link_condition_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (LinkCondition),
      0, /* n_preallocs */
      (GInstanceInitFunc) link_condition_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "LinkConditionType",
                                   &type_info, 0);
  }

  return type;
}

enum _MatchConditionProperties
{
  PROP_MATCH_CONDITION_0,
  PROP_MATCH_CONDITION_IS_NULL,
  PROP_MATCH_CONDITION_NODE_FIRST_CONDITION,
  PROP_MATCH_CONDITION_NODE_SECOND_CONDITION,
  PROP_MATCH_CONDITION_NODE_CROSS_CONDITION,
  PROP_MATCH_CONDITION_LINK_CONDITION
};

/* reads a match_condition object */
static gint32
match_condition_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  MatchCondition * this_object = MATCH_CONDITION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->is_null, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_is_null = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->node_first_condition), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_node_first_condition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->node_second_condition), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_node_second_condition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->node_cross_condition), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_node_cross_condition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->link_condition), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_link_condition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
match_condition_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  MatchCondition * this_object = MATCH_CONDITION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "MatchCondition", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "is_null", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->is_null, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "node_first_condition", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->node_first_condition), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "node_second_condition", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->node_second_condition), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "node_cross_condition", T_STRUCT, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->node_cross_condition), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "link_condition", T_STRUCT, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->link_condition), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
match_condition_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  MatchCondition *self = MATCH_CONDITION (object);

  switch (property_id)
  {
    case PROP_MATCH_CONDITION_IS_NULL:
      self->is_null = g_value_get_boolean (value);
      self->__isset_is_null = TRUE;
      break;

    case PROP_MATCH_CONDITION_NODE_FIRST_CONDITION:
      if (self->node_first_condition != NULL)
        g_object_unref (self->node_first_condition);
      self->node_first_condition = g_value_dup_object (value);
      self->__isset_node_first_condition = TRUE;
      break;

    case PROP_MATCH_CONDITION_NODE_SECOND_CONDITION:
      if (self->node_second_condition != NULL)
        g_object_unref (self->node_second_condition);
      self->node_second_condition = g_value_dup_object (value);
      self->__isset_node_second_condition = TRUE;
      break;

    case PROP_MATCH_CONDITION_NODE_CROSS_CONDITION:
      if (self->node_cross_condition != NULL)
        g_object_unref (self->node_cross_condition);
      self->node_cross_condition = g_value_dup_object (value);
      self->__isset_node_cross_condition = TRUE;
      break;

    case PROP_MATCH_CONDITION_LINK_CONDITION:
      if (self->link_condition != NULL)
        g_object_unref (self->link_condition);
      self->link_condition = g_value_dup_object (value);
      self->__isset_link_condition = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
match_condition_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  MatchCondition *self = MATCH_CONDITION (object);

  switch (property_id)
  {
    case PROP_MATCH_CONDITION_IS_NULL:
      g_value_set_boolean (value, self->is_null);
      break;

    case PROP_MATCH_CONDITION_NODE_FIRST_CONDITION:
      g_value_set_object (value, self->node_first_condition);
      break;

    case PROP_MATCH_CONDITION_NODE_SECOND_CONDITION:
      g_value_set_object (value, self->node_second_condition);
      break;

    case PROP_MATCH_CONDITION_NODE_CROSS_CONDITION:
      g_value_set_object (value, self->node_cross_condition);
      break;

    case PROP_MATCH_CONDITION_LINK_CONDITION:
      g_value_set_object (value, self->link_condition);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
match_condition_instance_init (MatchCondition * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->is_null = 0;
  object->__isset_is_null = FALSE;
  object->node_first_condition = g_object_new (TYPE_NODE_CONDITION, NULL);
  object->__isset_node_first_condition = FALSE;
  object->node_second_condition = g_object_new (TYPE_NODE_CONDITION, NULL);
  object->__isset_node_second_condition = FALSE;
  object->node_cross_condition = g_object_new (TYPE_NODE_CONDITION, NULL);
  object->__isset_node_cross_condition = FALSE;
  object->link_condition = g_object_new (TYPE_LINK_CONDITION, NULL);
  object->__isset_link_condition = FALSE;
}

static void 
match_condition_finalize (GObject *object)
{
  MatchCondition *tobject = MATCH_CONDITION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->node_first_condition != NULL)
  {
    g_object_unref(tobject->node_first_condition);
    tobject->node_first_condition = NULL;
  }
  if (tobject->node_second_condition != NULL)
  {
    g_object_unref(tobject->node_second_condition);
    tobject->node_second_condition = NULL;
  }
  if (tobject->node_cross_condition != NULL)
  {
    g_object_unref(tobject->node_cross_condition);
    tobject->node_cross_condition = NULL;
  }
  if (tobject->link_condition != NULL)
  {
    g_object_unref(tobject->link_condition);
    tobject->link_condition = NULL;
  }
}

static void
match_condition_class_init (MatchConditionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = match_condition_read;
  struct_class->write = match_condition_write;

  gobject_class->finalize = match_condition_finalize;
  gobject_class->get_property = match_condition_get_property;
  gobject_class->set_property = match_condition_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_MATCH_CONDITION_IS_NULL,
     g_param_spec_boolean ("is_null",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MATCH_CONDITION_NODE_FIRST_CONDITION,
     g_param_spec_object ("node_first_condition",
                         NULL,
                         NULL,
                         TYPE_NODE_CONDITION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MATCH_CONDITION_NODE_SECOND_CONDITION,
     g_param_spec_object ("node_second_condition",
                         NULL,
                         NULL,
                         TYPE_NODE_CONDITION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MATCH_CONDITION_NODE_CROSS_CONDITION,
     g_param_spec_object ("node_cross_condition",
                         NULL,
                         NULL,
                         TYPE_NODE_CONDITION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MATCH_CONDITION_LINK_CONDITION,
     g_param_spec_object ("link_condition",
                         NULL,
                         NULL,
                         TYPE_LINK_CONDITION,
                         G_PARAM_READWRITE));
}

GType
match_condition_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (MatchConditionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) match_condition_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (MatchCondition),
      0, /* n_preallocs */
      (GInstanceInitFunc) match_condition_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "MatchConditionType",
                                   &type_info, 0);
  }

  return type;
}

enum _SchemaCreateQueryProperties
{
  PROP_SCHEMA_CREATE_QUERY_0,
  PROP_SCHEMA_CREATE_QUERY_SCHEMA
};

/* reads a schema_create_query object */
static gint32
schema_create_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SchemaCreateQuery * this_object = SCHEMA_CREATE_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->schema), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_schema = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
schema_create_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SchemaCreateQuery * this_object = SCHEMA_CREATE_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SchemaCreateQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "schema", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->schema), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
schema_create_query_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  SchemaCreateQuery *self = SCHEMA_CREATE_QUERY (object);

  switch (property_id)
  {
    case PROP_SCHEMA_CREATE_QUERY_SCHEMA:
      if (self->schema != NULL)
        g_object_unref (self->schema);
      self->schema = g_value_dup_object (value);
      self->__isset_schema = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
schema_create_query_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  SchemaCreateQuery *self = SCHEMA_CREATE_QUERY (object);

  switch (property_id)
  {
    case PROP_SCHEMA_CREATE_QUERY_SCHEMA:
      g_value_set_object (value, self->schema);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
schema_create_query_instance_init (SchemaCreateQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->schema = g_object_new (TYPE_SCHEMA, NULL);
  object->__isset_schema = FALSE;
}

static void 
schema_create_query_finalize (GObject *object)
{
  SchemaCreateQuery *tobject = SCHEMA_CREATE_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->schema != NULL)
  {
    g_object_unref(tobject->schema);
    tobject->schema = NULL;
  }
}

static void
schema_create_query_class_init (SchemaCreateQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = schema_create_query_read;
  struct_class->write = schema_create_query_write;

  gobject_class->finalize = schema_create_query_finalize;
  gobject_class->get_property = schema_create_query_get_property;
  gobject_class->set_property = schema_create_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_CREATE_QUERY_SCHEMA,
     g_param_spec_object ("schema",
                         NULL,
                         NULL,
                         TYPE_SCHEMA,
                         G_PARAM_READWRITE));
}

GType
schema_create_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SchemaCreateQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) schema_create_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SchemaCreateQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) schema_create_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SchemaCreateQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _SchemaGetQueryProperties
{
  PROP_SCHEMA_GET_QUERY_0,
  PROP_SCHEMA_GET_QUERY_SCHEMA_NAME
};

/* reads a schema_get_query object */
static gint32
schema_get_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SchemaGetQuery * this_object = SCHEMA_GET_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->schema_name != NULL)
          {
            g_free(this_object->schema_name);
            this_object->schema_name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->schema_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_schema_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
schema_get_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SchemaGetQuery * this_object = SCHEMA_GET_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SchemaGetQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "schema_name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->schema_name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
schema_get_query_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  SchemaGetQuery *self = SCHEMA_GET_QUERY (object);

  switch (property_id)
  {
    case PROP_SCHEMA_GET_QUERY_SCHEMA_NAME:
      if (self->schema_name != NULL)
        g_free (self->schema_name);
      self->schema_name = g_value_dup_string (value);
      self->__isset_schema_name = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
schema_get_query_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  SchemaGetQuery *self = SCHEMA_GET_QUERY (object);

  switch (property_id)
  {
    case PROP_SCHEMA_GET_QUERY_SCHEMA_NAME:
      g_value_set_string (value, self->schema_name);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
schema_get_query_instance_init (SchemaGetQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->schema_name = NULL;
  object->__isset_schema_name = FALSE;
}

static void 
schema_get_query_finalize (GObject *object)
{
  SchemaGetQuery *tobject = SCHEMA_GET_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->schema_name != NULL)
  {
    g_free(tobject->schema_name);
    tobject->schema_name = NULL;
  }
}

static void
schema_get_query_class_init (SchemaGetQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = schema_get_query_read;
  struct_class->write = schema_get_query_write;

  gobject_class->finalize = schema_get_query_finalize;
  gobject_class->get_property = schema_get_query_get_property;
  gobject_class->set_property = schema_get_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_GET_QUERY_SCHEMA_NAME,
     g_param_spec_string ("schema_name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
schema_get_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SchemaGetQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) schema_get_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SchemaGetQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) schema_get_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SchemaGetQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _SchemaDeleteQueryProperties
{
  PROP_SCHEMA_DELETE_QUERY_0,
  PROP_SCHEMA_DELETE_QUERY_SCHEMA_NAME
};

/* reads a schema_delete_query object */
static gint32
schema_delete_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SchemaDeleteQuery * this_object = SCHEMA_DELETE_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->schema_name != NULL)
          {
            g_free(this_object->schema_name);
            this_object->schema_name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->schema_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_schema_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
schema_delete_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SchemaDeleteQuery * this_object = SCHEMA_DELETE_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SchemaDeleteQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "schema_name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->schema_name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
schema_delete_query_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  SchemaDeleteQuery *self = SCHEMA_DELETE_QUERY (object);

  switch (property_id)
  {
    case PROP_SCHEMA_DELETE_QUERY_SCHEMA_NAME:
      if (self->schema_name != NULL)
        g_free (self->schema_name);
      self->schema_name = g_value_dup_string (value);
      self->__isset_schema_name = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
schema_delete_query_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  SchemaDeleteQuery *self = SCHEMA_DELETE_QUERY (object);

  switch (property_id)
  {
    case PROP_SCHEMA_DELETE_QUERY_SCHEMA_NAME:
      g_value_set_string (value, self->schema_name);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
schema_delete_query_instance_init (SchemaDeleteQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->schema_name = NULL;
  object->__isset_schema_name = FALSE;
}

static void 
schema_delete_query_finalize (GObject *object)
{
  SchemaDeleteQuery *tobject = SCHEMA_DELETE_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->schema_name != NULL)
  {
    g_free(tobject->schema_name);
    tobject->schema_name = NULL;
  }
}

static void
schema_delete_query_class_init (SchemaDeleteQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = schema_delete_query_read;
  struct_class->write = schema_delete_query_write;

  gobject_class->finalize = schema_delete_query_finalize;
  gobject_class->get_property = schema_delete_query_get_property;
  gobject_class->set_property = schema_delete_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_DELETE_QUERY_SCHEMA_NAME,
     g_param_spec_string ("schema_name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
schema_delete_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SchemaDeleteQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) schema_delete_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SchemaDeleteQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) schema_delete_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SchemaDeleteQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _NodeCreateQueryProperties
{
  PROP_NODE_CREATE_QUERY_0,
  PROP_NODE_CREATE_QUERY_SCHEMA_NAME,
  PROP_NODE_CREATE_QUERY_NODE
};

/* reads a node_create_query object */
static gint32
node_create_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NodeCreateQuery * this_object = NODE_CREATE_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->schema_name != NULL)
          {
            g_free(this_object->schema_name);
            this_object->schema_name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->schema_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_schema_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->node), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_node = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
node_create_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NodeCreateQuery * this_object = NODE_CREATE_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NodeCreateQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "schema_name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->schema_name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "node", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->node), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
node_create_query_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  NodeCreateQuery *self = NODE_CREATE_QUERY (object);

  switch (property_id)
  {
    case PROP_NODE_CREATE_QUERY_SCHEMA_NAME:
      if (self->schema_name != NULL)
        g_free (self->schema_name);
      self->schema_name = g_value_dup_string (value);
      self->__isset_schema_name = TRUE;
      break;

    case PROP_NODE_CREATE_QUERY_NODE:
      if (self->node != NULL)
        g_object_unref (self->node);
      self->node = g_value_dup_object (value);
      self->__isset_node = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
node_create_query_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  NodeCreateQuery *self = NODE_CREATE_QUERY (object);

  switch (property_id)
  {
    case PROP_NODE_CREATE_QUERY_SCHEMA_NAME:
      g_value_set_string (value, self->schema_name);
      break;

    case PROP_NODE_CREATE_QUERY_NODE:
      g_value_set_object (value, self->node);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
node_create_query_instance_init (NodeCreateQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->schema_name = NULL;
  object->__isset_schema_name = FALSE;
  object->node = g_object_new (TYPE_NODE, NULL);
  object->__isset_node = FALSE;
}

static void 
node_create_query_finalize (GObject *object)
{
  NodeCreateQuery *tobject = NODE_CREATE_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->schema_name != NULL)
  {
    g_free(tobject->schema_name);
    tobject->schema_name = NULL;
  }
  if (tobject->node != NULL)
  {
    g_object_unref(tobject->node);
    tobject->node = NULL;
  }
}

static void
node_create_query_class_init (NodeCreateQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = node_create_query_read;
  struct_class->write = node_create_query_write;

  gobject_class->finalize = node_create_query_finalize;
  gobject_class->get_property = node_create_query_get_property;
  gobject_class->set_property = node_create_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NODE_CREATE_QUERY_SCHEMA_NAME,
     g_param_spec_string ("schema_name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NODE_CREATE_QUERY_NODE,
     g_param_spec_object ("node",
                         NULL,
                         NULL,
                         TYPE_NODE,
                         G_PARAM_READWRITE));
}

GType
node_create_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NodeCreateQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) node_create_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NodeCreateQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) node_create_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NodeCreateQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _NodeUpdateQueryProperties
{
  PROP_NODE_UPDATE_QUERY_0,
  PROP_NODE_UPDATE_QUERY_CONDITION,
  PROP_NODE_UPDATE_QUERY_PROPERTIES
};

/* reads a node_update_query object */
static gint32
node_update_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NodeUpdateQuery * this_object = NODE_UPDATE_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->condition), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_condition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Property * _elem17 = NULL;
              if ( _elem17 != NULL)
              {
                g_object_unref (_elem17);
              }
              _elem17 = g_object_new (TYPE_PROPERTY, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem17), protocol, error)) < 0)
              {
                g_object_unref (_elem17);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->properties, _elem17);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_properties = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
node_update_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NodeUpdateQuery * this_object = NODE_UPDATE_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NodeUpdateQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "condition", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->condition), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "properties", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i18;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->properties ? this_object->properties->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i18 = 0; i18 < (this_object->properties ? this_object->properties->len : 0); i18++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->properties, i18))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
node_update_query_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  NodeUpdateQuery *self = NODE_UPDATE_QUERY (object);

  switch (property_id)
  {
    case PROP_NODE_UPDATE_QUERY_CONDITION:
      if (self->condition != NULL)
        g_object_unref (self->condition);
      self->condition = g_value_dup_object (value);
      self->__isset_condition = TRUE;
      break;

    case PROP_NODE_UPDATE_QUERY_PROPERTIES:
      if (self->properties != NULL)
        g_ptr_array_unref (self->properties);
      self->properties = g_value_dup_boxed (value);
      self->__isset_properties = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
node_update_query_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  NodeUpdateQuery *self = NODE_UPDATE_QUERY (object);

  switch (property_id)
  {
    case PROP_NODE_UPDATE_QUERY_CONDITION:
      g_value_set_object (value, self->condition);
      break;

    case PROP_NODE_UPDATE_QUERY_PROPERTIES:
      g_value_set_boxed (value, self->properties);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
node_update_query_instance_init (NodeUpdateQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->condition = g_object_new (TYPE_NODE_CONDITION, NULL);
  object->__isset_condition = FALSE;
  object->properties = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_properties = FALSE;
}

static void 
node_update_query_finalize (GObject *object)
{
  NodeUpdateQuery *tobject = NODE_UPDATE_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->condition != NULL)
  {
    g_object_unref(tobject->condition);
    tobject->condition = NULL;
  }
  if (tobject->properties != NULL)
  {
    g_ptr_array_unref (tobject->properties);
    tobject->properties = NULL;
  }
}

static void
node_update_query_class_init (NodeUpdateQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = node_update_query_read;
  struct_class->write = node_update_query_write;

  gobject_class->finalize = node_update_query_finalize;
  gobject_class->get_property = node_update_query_get_property;
  gobject_class->set_property = node_update_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NODE_UPDATE_QUERY_CONDITION,
     g_param_spec_object ("condition",
                         NULL,
                         NULL,
                         TYPE_NODE_CONDITION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NODE_UPDATE_QUERY_PROPERTIES,
     g_param_spec_boxed ("properties",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
node_update_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NodeUpdateQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) node_update_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NodeUpdateQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) node_update_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NodeUpdateQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _NodeDeleteQueryProperties
{
  PROP_NODE_DELETE_QUERY_0,
  PROP_NODE_DELETE_QUERY_CONDITION
};

/* reads a node_delete_query object */
static gint32
node_delete_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NodeDeleteQuery * this_object = NODE_DELETE_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->condition), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_condition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
node_delete_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NodeDeleteQuery * this_object = NODE_DELETE_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NodeDeleteQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "condition", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->condition), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
node_delete_query_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  NodeDeleteQuery *self = NODE_DELETE_QUERY (object);

  switch (property_id)
  {
    case PROP_NODE_DELETE_QUERY_CONDITION:
      if (self->condition != NULL)
        g_object_unref (self->condition);
      self->condition = g_value_dup_object (value);
      self->__isset_condition = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
node_delete_query_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  NodeDeleteQuery *self = NODE_DELETE_QUERY (object);

  switch (property_id)
  {
    case PROP_NODE_DELETE_QUERY_CONDITION:
      g_value_set_object (value, self->condition);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
node_delete_query_instance_init (NodeDeleteQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->condition = g_object_new (TYPE_NODE_CONDITION, NULL);
  object->__isset_condition = FALSE;
}

static void 
node_delete_query_finalize (GObject *object)
{
  NodeDeleteQuery *tobject = NODE_DELETE_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->condition != NULL)
  {
    g_object_unref(tobject->condition);
    tobject->condition = NULL;
  }
}

static void
node_delete_query_class_init (NodeDeleteQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = node_delete_query_read;
  struct_class->write = node_delete_query_write;

  gobject_class->finalize = node_delete_query_finalize;
  gobject_class->get_property = node_delete_query_get_property;
  gobject_class->set_property = node_delete_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NODE_DELETE_QUERY_CONDITION,
     g_param_spec_object ("condition",
                         NULL,
                         NULL,
                         TYPE_NODE_CONDITION,
                         G_PARAM_READWRITE));
}

GType
node_delete_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NodeDeleteQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) node_delete_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NodeDeleteQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) node_delete_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NodeDeleteQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _NodeMatchQueryProperties
{
  PROP_NODE_MATCH_QUERY_0,
  PROP_NODE_MATCH_QUERY_CONDITION
};

/* reads a node_match_query object */
static gint32
node_match_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NodeMatchQuery * this_object = NODE_MATCH_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->condition), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_condition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
node_match_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NodeMatchQuery * this_object = NODE_MATCH_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NodeMatchQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "condition", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->condition), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
node_match_query_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  NodeMatchQuery *self = NODE_MATCH_QUERY (object);

  switch (property_id)
  {
    case PROP_NODE_MATCH_QUERY_CONDITION:
      if (self->condition != NULL)
        g_object_unref (self->condition);
      self->condition = g_value_dup_object (value);
      self->__isset_condition = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
node_match_query_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  NodeMatchQuery *self = NODE_MATCH_QUERY (object);

  switch (property_id)
  {
    case PROP_NODE_MATCH_QUERY_CONDITION:
      g_value_set_object (value, self->condition);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
node_match_query_instance_init (NodeMatchQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->condition = g_object_new (TYPE_NODE_CONDITION, NULL);
  object->__isset_condition = FALSE;
}

static void 
node_match_query_finalize (GObject *object)
{
  NodeMatchQuery *tobject = NODE_MATCH_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->condition != NULL)
  {
    g_object_unref(tobject->condition);
    tobject->condition = NULL;
  }
}

static void
node_match_query_class_init (NodeMatchQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = node_match_query_read;
  struct_class->write = node_match_query_write;

  gobject_class->finalize = node_match_query_finalize;
  gobject_class->get_property = node_match_query_get_property;
  gobject_class->set_property = node_match_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NODE_MATCH_QUERY_CONDITION,
     g_param_spec_object ("condition",
                         NULL,
                         NULL,
                         TYPE_NODE_CONDITION,
                         G_PARAM_READWRITE));
}

GType
node_match_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NodeMatchQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) node_match_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NodeMatchQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) node_match_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NodeMatchQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _LinkCreateQueryProperties
{
  PROP_LINK_CREATE_QUERY_0,
  PROP_LINK_CREATE_QUERY_LINK
};

/* reads a link_create_query object */
static gint32
link_create_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  LinkCreateQuery * this_object = LINK_CREATE_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->link), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_link = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
link_create_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  LinkCreateQuery * this_object = LINK_CREATE_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "LinkCreateQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "link", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->link), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
link_create_query_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  LinkCreateQuery *self = LINK_CREATE_QUERY (object);

  switch (property_id)
  {
    case PROP_LINK_CREATE_QUERY_LINK:
      if (self->link != NULL)
        g_object_unref (self->link);
      self->link = g_value_dup_object (value);
      self->__isset_link = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
link_create_query_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  LinkCreateQuery *self = LINK_CREATE_QUERY (object);

  switch (property_id)
  {
    case PROP_LINK_CREATE_QUERY_LINK:
      g_value_set_object (value, self->link);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
link_create_query_instance_init (LinkCreateQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->link = g_object_new (TYPE_LINK, NULL);
  object->__isset_link = FALSE;
}

static void 
link_create_query_finalize (GObject *object)
{
  LinkCreateQuery *tobject = LINK_CREATE_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->link != NULL)
  {
    g_object_unref(tobject->link);
    tobject->link = NULL;
  }
}

static void
link_create_query_class_init (LinkCreateQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = link_create_query_read;
  struct_class->write = link_create_query_write;

  gobject_class->finalize = link_create_query_finalize;
  gobject_class->get_property = link_create_query_get_property;
  gobject_class->set_property = link_create_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_LINK_CREATE_QUERY_LINK,
     g_param_spec_object ("link",
                         NULL,
                         NULL,
                         TYPE_LINK,
                         G_PARAM_READWRITE));
}

GType
link_create_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (LinkCreateQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) link_create_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (LinkCreateQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) link_create_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "LinkCreateQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _LinkDeleteQueryProperties
{
  PROP_LINK_DELETE_QUERY_0,
  PROP_LINK_DELETE_QUERY_CONDITION
};

/* reads a link_delete_query object */
static gint32
link_delete_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  LinkDeleteQuery * this_object = LINK_DELETE_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->condition), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_condition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
link_delete_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  LinkDeleteQuery * this_object = LINK_DELETE_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "LinkDeleteQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "condition", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->condition), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
link_delete_query_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  LinkDeleteQuery *self = LINK_DELETE_QUERY (object);

  switch (property_id)
  {
    case PROP_LINK_DELETE_QUERY_CONDITION:
      if (self->condition != NULL)
        g_object_unref (self->condition);
      self->condition = g_value_dup_object (value);
      self->__isset_condition = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
link_delete_query_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  LinkDeleteQuery *self = LINK_DELETE_QUERY (object);

  switch (property_id)
  {
    case PROP_LINK_DELETE_QUERY_CONDITION:
      g_value_set_object (value, self->condition);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
link_delete_query_instance_init (LinkDeleteQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->condition = g_object_new (TYPE_MATCH_CONDITION, NULL);
  object->__isset_condition = FALSE;
}

static void 
link_delete_query_finalize (GObject *object)
{
  LinkDeleteQuery *tobject = LINK_DELETE_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->condition != NULL)
  {
    g_object_unref(tobject->condition);
    tobject->condition = NULL;
  }
}

static void
link_delete_query_class_init (LinkDeleteQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = link_delete_query_read;
  struct_class->write = link_delete_query_write;

  gobject_class->finalize = link_delete_query_finalize;
  gobject_class->get_property = link_delete_query_get_property;
  gobject_class->set_property = link_delete_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_LINK_DELETE_QUERY_CONDITION,
     g_param_spec_object ("condition",
                         NULL,
                         NULL,
                         TYPE_MATCH_CONDITION,
                         G_PARAM_READWRITE));
}

GType
link_delete_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (LinkDeleteQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) link_delete_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (LinkDeleteQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) link_delete_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "LinkDeleteQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _MatchQueryProperties
{
  PROP_MATCH_QUERY_0,
  PROP_MATCH_QUERY_CONDITION
};

/* reads a match_query object */
static gint32
match_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  MatchQuery * this_object = MATCH_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->condition), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_condition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
match_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  MatchQuery * this_object = MATCH_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "MatchQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "condition", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->condition), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
match_query_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  MatchQuery *self = MATCH_QUERY (object);

  switch (property_id)
  {
    case PROP_MATCH_QUERY_CONDITION:
      if (self->condition != NULL)
        g_object_unref (self->condition);
      self->condition = g_value_dup_object (value);
      self->__isset_condition = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
match_query_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  MatchQuery *self = MATCH_QUERY (object);

  switch (property_id)
  {
    case PROP_MATCH_QUERY_CONDITION:
      g_value_set_object (value, self->condition);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
match_query_instance_init (MatchQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->condition = g_object_new (TYPE_MATCH_CONDITION, NULL);
  object->__isset_condition = FALSE;
}

static void 
match_query_finalize (GObject *object)
{
  MatchQuery *tobject = MATCH_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->condition != NULL)
  {
    g_object_unref(tobject->condition);
    tobject->condition = NULL;
  }
}

static void
match_query_class_init (MatchQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = match_query_read;
  struct_class->write = match_query_write;

  gobject_class->finalize = match_query_finalize;
  gobject_class->get_property = match_query_get_property;
  gobject_class->set_property = match_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_MATCH_QUERY_CONDITION,
     g_param_spec_object ("condition",
                         NULL,
                         NULL,
                         TYPE_MATCH_CONDITION,
                         G_PARAM_READWRITE));
}

GType
match_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (MatchQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) match_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (MatchQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) match_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "MatchQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _uQueryProperties
{
  PROP_U_QUERY_0,
  PROP_U_QUERY_SCHEMA_CREATE_QUERY,
  PROP_U_QUERY_SCHEMA_GET_QUERY,
  PROP_U_QUERY_SCHEMA_DELETE_QUERY,
  PROP_U_QUERY_NODE_CREATE_QUERY,
  PROP_U_QUERY_NODE_UPDATE_QUERY,
  PROP_U_QUERY_NODE_DELETE_QUERY,
  PROP_U_QUERY_NODE_MATCH_QUERY,
  PROP_U_QUERY_LINK_CREATE_QUERY,
  PROP_U_QUERY_LINK_DELETE_QUERY,
  PROP_U_QUERY_MATCH_QUERY
};

/* reads a u_query object */
static gint32
u_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  uQuery * this_object = U_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->schema_create_query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_schema_create_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->schema_get_query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_schema_get_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->schema_delete_query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_schema_delete_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->node_create_query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_node_create_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->node_update_query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_node_update_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->node_delete_query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_node_delete_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->node_match_query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_node_match_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->link_create_query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_link_create_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->link_delete_query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_link_delete_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->match_query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_match_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
u_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  uQuery * this_object = U_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "uQuery", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_schema_create_query == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "schema_create_query", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->schema_create_query), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_schema_get_query == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "schema_get_query", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->schema_get_query), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_schema_delete_query == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "schema_delete_query", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->schema_delete_query), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_node_create_query == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "node_create_query", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->node_create_query), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_node_update_query == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "node_update_query", T_STRUCT, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->node_update_query), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_node_delete_query == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "node_delete_query", T_STRUCT, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->node_delete_query), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_node_match_query == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "node_match_query", T_STRUCT, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->node_match_query), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_link_create_query == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "link_create_query", T_STRUCT, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->link_create_query), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_link_delete_query == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "link_delete_query", T_STRUCT, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->link_delete_query), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_match_query == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "match_query", T_STRUCT, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->match_query), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
u_query_set_property (GObject *object,
                      guint property_id,
                      const GValue *value,
                      GParamSpec *pspec)
{
  uQuery *self = U_QUERY (object);

  switch (property_id)
  {
    case PROP_U_QUERY_SCHEMA_CREATE_QUERY:
      if (self->schema_create_query != NULL)
        g_object_unref (self->schema_create_query);
      self->schema_create_query = g_value_dup_object (value);
      self->__isset_schema_create_query = TRUE;
      break;

    case PROP_U_QUERY_SCHEMA_GET_QUERY:
      if (self->schema_get_query != NULL)
        g_object_unref (self->schema_get_query);
      self->schema_get_query = g_value_dup_object (value);
      self->__isset_schema_get_query = TRUE;
      break;

    case PROP_U_QUERY_SCHEMA_DELETE_QUERY:
      if (self->schema_delete_query != NULL)
        g_object_unref (self->schema_delete_query);
      self->schema_delete_query = g_value_dup_object (value);
      self->__isset_schema_delete_query = TRUE;
      break;

    case PROP_U_QUERY_NODE_CREATE_QUERY:
      if (self->node_create_query != NULL)
        g_object_unref (self->node_create_query);
      self->node_create_query = g_value_dup_object (value);
      self->__isset_node_create_query = TRUE;
      break;

    case PROP_U_QUERY_NODE_UPDATE_QUERY:
      if (self->node_update_query != NULL)
        g_object_unref (self->node_update_query);
      self->node_update_query = g_value_dup_object (value);
      self->__isset_node_update_query = TRUE;
      break;

    case PROP_U_QUERY_NODE_DELETE_QUERY:
      if (self->node_delete_query != NULL)
        g_object_unref (self->node_delete_query);
      self->node_delete_query = g_value_dup_object (value);
      self->__isset_node_delete_query = TRUE;
      break;

    case PROP_U_QUERY_NODE_MATCH_QUERY:
      if (self->node_match_query != NULL)
        g_object_unref (self->node_match_query);
      self->node_match_query = g_value_dup_object (value);
      self->__isset_node_match_query = TRUE;
      break;

    case PROP_U_QUERY_LINK_CREATE_QUERY:
      if (self->link_create_query != NULL)
        g_object_unref (self->link_create_query);
      self->link_create_query = g_value_dup_object (value);
      self->__isset_link_create_query = TRUE;
      break;

    case PROP_U_QUERY_LINK_DELETE_QUERY:
      if (self->link_delete_query != NULL)
        g_object_unref (self->link_delete_query);
      self->link_delete_query = g_value_dup_object (value);
      self->__isset_link_delete_query = TRUE;
      break;

    case PROP_U_QUERY_MATCH_QUERY:
      if (self->match_query != NULL)
        g_object_unref (self->match_query);
      self->match_query = g_value_dup_object (value);
      self->__isset_match_query = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
u_query_get_property (GObject *object,
                      guint property_id,
                      GValue *value,
                      GParamSpec *pspec)
{
  uQuery *self = U_QUERY (object);

  switch (property_id)
  {
    case PROP_U_QUERY_SCHEMA_CREATE_QUERY:
      g_value_set_object (value, self->schema_create_query);
      break;

    case PROP_U_QUERY_SCHEMA_GET_QUERY:
      g_value_set_object (value, self->schema_get_query);
      break;

    case PROP_U_QUERY_SCHEMA_DELETE_QUERY:
      g_value_set_object (value, self->schema_delete_query);
      break;

    case PROP_U_QUERY_NODE_CREATE_QUERY:
      g_value_set_object (value, self->node_create_query);
      break;

    case PROP_U_QUERY_NODE_UPDATE_QUERY:
      g_value_set_object (value, self->node_update_query);
      break;

    case PROP_U_QUERY_NODE_DELETE_QUERY:
      g_value_set_object (value, self->node_delete_query);
      break;

    case PROP_U_QUERY_NODE_MATCH_QUERY:
      g_value_set_object (value, self->node_match_query);
      break;

    case PROP_U_QUERY_LINK_CREATE_QUERY:
      g_value_set_object (value, self->link_create_query);
      break;

    case PROP_U_QUERY_LINK_DELETE_QUERY:
      g_value_set_object (value, self->link_delete_query);
      break;

    case PROP_U_QUERY_MATCH_QUERY:
      g_value_set_object (value, self->match_query);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
u_query_instance_init (uQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->schema_create_query = g_object_new (TYPE_SCHEMA_CREATE_QUERY, NULL);
  object->__isset_schema_create_query = FALSE;
  object->schema_get_query = g_object_new (TYPE_SCHEMA_GET_QUERY, NULL);
  object->__isset_schema_get_query = FALSE;
  object->schema_delete_query = g_object_new (TYPE_SCHEMA_DELETE_QUERY, NULL);
  object->__isset_schema_delete_query = FALSE;
  object->node_create_query = g_object_new (TYPE_NODE_CREATE_QUERY, NULL);
  object->__isset_node_create_query = FALSE;
  object->node_update_query = g_object_new (TYPE_NODE_UPDATE_QUERY, NULL);
  object->__isset_node_update_query = FALSE;
  object->node_delete_query = g_object_new (TYPE_NODE_DELETE_QUERY, NULL);
  object->__isset_node_delete_query = FALSE;
  object->node_match_query = g_object_new (TYPE_NODE_MATCH_QUERY, NULL);
  object->__isset_node_match_query = FALSE;
  object->link_create_query = g_object_new (TYPE_LINK_CREATE_QUERY, NULL);
  object->__isset_link_create_query = FALSE;
  object->link_delete_query = g_object_new (TYPE_LINK_DELETE_QUERY, NULL);
  object->__isset_link_delete_query = FALSE;
  object->match_query = g_object_new (TYPE_MATCH_QUERY, NULL);
  object->__isset_match_query = FALSE;
}

static void 
u_query_finalize (GObject *object)
{
  uQuery *tobject = U_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->schema_create_query != NULL)
  {
    g_object_unref(tobject->schema_create_query);
    tobject->schema_create_query = NULL;
  }
  if (tobject->schema_get_query != NULL)
  {
    g_object_unref(tobject->schema_get_query);
    tobject->schema_get_query = NULL;
  }
  if (tobject->schema_delete_query != NULL)
  {
    g_object_unref(tobject->schema_delete_query);
    tobject->schema_delete_query = NULL;
  }
  if (tobject->node_create_query != NULL)
  {
    g_object_unref(tobject->node_create_query);
    tobject->node_create_query = NULL;
  }
  if (tobject->node_update_query != NULL)
  {
    g_object_unref(tobject->node_update_query);
    tobject->node_update_query = NULL;
  }
  if (tobject->node_delete_query != NULL)
  {
    g_object_unref(tobject->node_delete_query);
    tobject->node_delete_query = NULL;
  }
  if (tobject->node_match_query != NULL)
  {
    g_object_unref(tobject->node_match_query);
    tobject->node_match_query = NULL;
  }
  if (tobject->link_create_query != NULL)
  {
    g_object_unref(tobject->link_create_query);
    tobject->link_create_query = NULL;
  }
  if (tobject->link_delete_query != NULL)
  {
    g_object_unref(tobject->link_delete_query);
    tobject->link_delete_query = NULL;
  }
  if (tobject->match_query != NULL)
  {
    g_object_unref(tobject->match_query);
    tobject->match_query = NULL;
  }
}

static void
u_query_class_init (uQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = u_query_read;
  struct_class->write = u_query_write;

  gobject_class->finalize = u_query_finalize;
  gobject_class->get_property = u_query_get_property;
  gobject_class->set_property = u_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_U_QUERY_SCHEMA_CREATE_QUERY,
     g_param_spec_object ("schema_create_query",
                         NULL,
                         NULL,
                         TYPE_SCHEMA_CREATE_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_U_QUERY_SCHEMA_GET_QUERY,
     g_param_spec_object ("schema_get_query",
                         NULL,
                         NULL,
                         TYPE_SCHEMA_GET_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_U_QUERY_SCHEMA_DELETE_QUERY,
     g_param_spec_object ("schema_delete_query",
                         NULL,
                         NULL,
                         TYPE_SCHEMA_DELETE_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_U_QUERY_NODE_CREATE_QUERY,
     g_param_spec_object ("node_create_query",
                         NULL,
                         NULL,
                         TYPE_NODE_CREATE_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_U_QUERY_NODE_UPDATE_QUERY,
     g_param_spec_object ("node_update_query",
                         NULL,
                         NULL,
                         TYPE_NODE_UPDATE_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_U_QUERY_NODE_DELETE_QUERY,
     g_param_spec_object ("node_delete_query",
                         NULL,
                         NULL,
                         TYPE_NODE_DELETE_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_U_QUERY_NODE_MATCH_QUERY,
     g_param_spec_object ("node_match_query",
                         NULL,
                         NULL,
                         TYPE_NODE_MATCH_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_U_QUERY_LINK_CREATE_QUERY,
     g_param_spec_object ("link_create_query",
                         NULL,
                         NULL,
                         TYPE_LINK_CREATE_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_U_QUERY_LINK_DELETE_QUERY,
     g_param_spec_object ("link_delete_query",
                         NULL,
                         NULL,
                         TYPE_LINK_DELETE_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_U_QUERY_MATCH_QUERY,
     g_param_spec_object ("match_query",
                         NULL,
                         NULL,
                         TYPE_MATCH_QUERY,
                         G_PARAM_READWRITE));
}

GType
u_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (uQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) u_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (uQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) u_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "uQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _QueryProperties
{
  PROP_QUERY_0,
  PROP_QUERY_TYPE,
  PROP_QUERY_QUERY
};

/* reads a query object */
static gint32
query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Query * this_object = QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast19;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast19, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (QueryType)ecast19;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Query * this_object = QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Query", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "query", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->query), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
query_set_property (GObject *object,
                    guint property_id,
                    const GValue *value,
                    GParamSpec *pspec)
{
  Query *self = QUERY (object);

  switch (property_id)
  {
    case PROP_QUERY_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_QUERY_QUERY:
      if (self->query != NULL)
        g_object_unref (self->query);
      self->query = g_value_dup_object (value);
      self->__isset_query = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
query_get_property (GObject *object,
                    guint property_id,
                    GValue *value,
                    GParamSpec *pspec)
{
  Query *self = QUERY (object);

  switch (property_id)
  {
    case PROP_QUERY_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_QUERY_QUERY:
      g_value_set_object (value, self->query);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
query_instance_init (Query * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->query = g_object_new (TYPE_U_QUERY, NULL);
  object->__isset_query = FALSE;
}

static void 
query_finalize (GObject *object)
{
  Query *tobject = QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->query != NULL)
  {
    g_object_unref(tobject->query);
    tobject->query = NULL;
  }
}

static void
query_class_init (QueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = query_read;
  struct_class->write = query_write;

  gobject_class->finalize = query_finalize;
  gobject_class->get_property = query_get_property;
  gobject_class->set_property = query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_QUERY_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       10,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_QUERY_QUERY,
     g_param_spec_object ("query",
                         NULL,
                         NULL,
                         TYPE_U_QUERY,
                         G_PARAM_READWRITE));
}

GType
query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (QueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Query),
      0, /* n_preallocs */
      (GInstanceInitFunc) query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "QueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _ResultProperties
{
  PROP_RESULT_0,
  PROP_RESULT_RETURN_ITEMS,
  PROP_RESULT_FIRST,
  PROP_RESULT_LINK,
  PROP_RESULT_SECOND
};

/* reads a result object */
static gint32
result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Result * this_object = RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast20;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast20, error)) < 0)
            return -1;
          xfer += ret;
          this_object->return_items = (Return)ecast20;
          this_object->__isset_return_items = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->first), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_first = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->link), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_link = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->second), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_second = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Result * this_object = RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Result", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "return_items", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->return_items, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_first == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "first", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->first), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_link == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "link", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->link), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_second == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "second", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->second), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
result_set_property (GObject *object,
                     guint property_id,
                     const GValue *value,
                     GParamSpec *pspec)
{
  Result *self = RESULT (object);

  switch (property_id)
  {
    case PROP_RESULT_RETURN_ITEMS:
      self->return_items = g_value_get_int (value);
      self->__isset_return_items = TRUE;
      break;

    case PROP_RESULT_FIRST:
      if (self->first != NULL)
        g_object_unref (self->first);
      self->first = g_value_dup_object (value);
      self->__isset_first = TRUE;
      break;

    case PROP_RESULT_LINK:
      if (self->link != NULL)
        g_object_unref (self->link);
      self->link = g_value_dup_object (value);
      self->__isset_link = TRUE;
      break;

    case PROP_RESULT_SECOND:
      if (self->second != NULL)
        g_object_unref (self->second);
      self->second = g_value_dup_object (value);
      self->__isset_second = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
result_get_property (GObject *object,
                     guint property_id,
                     GValue *value,
                     GParamSpec *pspec)
{
  Result *self = RESULT (object);

  switch (property_id)
  {
    case PROP_RESULT_RETURN_ITEMS:
      g_value_set_int (value, self->return_items);
      break;

    case PROP_RESULT_FIRST:
      g_value_set_object (value, self->first);
      break;

    case PROP_RESULT_LINK:
      g_value_set_object (value, self->link);
      break;

    case PROP_RESULT_SECOND:
      g_value_set_object (value, self->second);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
result_instance_init (Result * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_return_items = FALSE;
  object->first = g_object_new (TYPE_NODE, NULL);
  object->__isset_first = FALSE;
  object->link = g_object_new (TYPE_LINK, NULL);
  object->__isset_link = FALSE;
  object->second = g_object_new (TYPE_NODE, NULL);
  object->__isset_second = FALSE;
}

static void 
result_finalize (GObject *object)
{
  Result *tobject = RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->first != NULL)
  {
    g_object_unref(tobject->first);
    tobject->first = NULL;
  }
  if (tobject->link != NULL)
  {
    g_object_unref(tobject->link);
    tobject->link = NULL;
  }
  if (tobject->second != NULL)
  {
    g_object_unref(tobject->second);
    tobject->second = NULL;
  }
}

static void
result_class_init (ResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = result_read;
  struct_class->write = result_write;

  gobject_class->finalize = result_finalize;
  gobject_class->get_property = result_get_property;
  gobject_class->set_property = result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_RESULT_RETURN_ITEMS,
     g_param_spec_int ("return_items",
                       NULL,
                       NULL,
                       0,
                       8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RESULT_FIRST,
     g_param_spec_object ("first",
                         NULL,
                         NULL,
                         TYPE_NODE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RESULT_LINK,
     g_param_spec_object ("link",
                         NULL,
                         NULL,
                         TYPE_LINK,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RESULT_SECOND,
     g_param_spec_object ("second",
                         NULL,
                         NULL,
                         TYPE_NODE,
                         G_PARAM_READWRITE));
}

GType
result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Result),
      0, /* n_preallocs */
      (GInstanceInitFunc) result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _uQueryResultProperties
{
  PROP_U_QUERY_RESULT_0,
  PROP_U_QUERY_RESULT_SCHEMA,
  PROP_U_QUERY_RESULT_ITEMS
};

/* reads a u_query_result object */
static gint32
u_query_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  uQueryResult * this_object = U_QUERY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Schema * _elem21 = NULL;
              if ( _elem21 != NULL)
              {
                g_object_unref (_elem21);
              }
              _elem21 = g_object_new (TYPE_SCHEMA, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem21), protocol, error)) < 0)
              {
                g_object_unref (_elem21);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->schema, _elem21);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_schema = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Result * _elem22 = NULL;
              if ( _elem22 != NULL)
              {
                g_object_unref (_elem22);
              }
              _elem22 = g_object_new (TYPE_RESULT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem22), protocol, error)) < 0)
              {
                g_object_unref (_elem22);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->items, _elem22);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_items = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
u_query_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  uQueryResult * this_object = U_QUERY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "uQueryResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_schema == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "schema", T_LIST, 1, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i23;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->schema ? this_object->schema->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i23 = 0; i23 < (this_object->schema ? this_object->schema->len : 0); i23++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->schema, i23))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_items == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "items", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i24;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->items ? this_object->items->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i24 = 0; i24 < (this_object->items ? this_object->items->len : 0); i24++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->items, i24))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
u_query_result_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  uQueryResult *self = U_QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_U_QUERY_RESULT_SCHEMA:
      if (self->schema != NULL)
        g_ptr_array_unref (self->schema);
      self->schema = g_value_dup_boxed (value);
      self->__isset_schema = TRUE;
      break;

    case PROP_U_QUERY_RESULT_ITEMS:
      if (self->items != NULL)
        g_ptr_array_unref (self->items);
      self->items = g_value_dup_boxed (value);
      self->__isset_items = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
u_query_result_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  uQueryResult *self = U_QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_U_QUERY_RESULT_SCHEMA:
      g_value_set_boxed (value, self->schema);
      break;

    case PROP_U_QUERY_RESULT_ITEMS:
      g_value_set_boxed (value, self->items);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
u_query_result_instance_init (uQueryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->schema = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_schema = FALSE;
  object->items = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_items = FALSE;
}

static void 
u_query_result_finalize (GObject *object)
{
  uQueryResult *tobject = U_QUERY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->schema != NULL)
  {
    g_ptr_array_unref (tobject->schema);
    tobject->schema = NULL;
  }
  if (tobject->items != NULL)
  {
    g_ptr_array_unref (tobject->items);
    tobject->items = NULL;
  }
}

static void
u_query_result_class_init (uQueryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = u_query_result_read;
  struct_class->write = u_query_result_write;

  gobject_class->finalize = u_query_result_finalize;
  gobject_class->get_property = u_query_result_get_property;
  gobject_class->set_property = u_query_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_U_QUERY_RESULT_SCHEMA,
     g_param_spec_boxed ("schema",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_U_QUERY_RESULT_ITEMS,
     g_param_spec_boxed ("items",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
u_query_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (uQueryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) u_query_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (uQueryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) u_query_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "uQueryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _QueryResultProperties
{
  PROP_QUERY_RESULT_0,
  PROP_QUERY_RESULT_TYPE,
  PROP_QUERY_RESULT_MESSAGE,
  PROP_QUERY_RESULT_RESULT
};

/* reads a query_result object */
static gint32
query_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  QueryResult * this_object = QUERY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast25;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast25, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (QueryResultType)ecast25;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->result), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_result = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
query_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  QueryResult * this_object = QUERY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "QueryResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_result == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "result", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->result), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
query_result_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  QueryResult *self = QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_QUERY_RESULT_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_QUERY_RESULT_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    case PROP_QUERY_RESULT_RESULT:
      if (self->result != NULL)
        g_object_unref (self->result);
      self->result = g_value_dup_object (value);
      self->__isset_result = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
query_result_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  QueryResult *self = QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_QUERY_RESULT_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_QUERY_RESULT_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    case PROP_QUERY_RESULT_RESULT:
      g_value_set_object (value, self->result);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
query_result_instance_init (QueryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->message = NULL;
  object->__isset_message = FALSE;
  object->result = g_object_new (TYPE_U_QUERY_RESULT, NULL);
  object->__isset_result = FALSE;
}

static void 
query_result_finalize (GObject *object)
{
  QueryResult *tobject = QUERY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
  if (tobject->result != NULL)
  {
    g_object_unref(tobject->result);
    tobject->result = NULL;
  }
}

static void
query_result_class_init (QueryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = query_result_read;
  struct_class->write = query_result_write;

  gobject_class->finalize = query_result_finalize;
  gobject_class->get_property = query_result_get_property;
  gobject_class->set_property = query_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_QUERY_RESULT_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       2,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_QUERY_RESULT_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_QUERY_RESULT_RESULT,
     g_param_spec_object ("result",
                         NULL,
                         NULL,
                         TYPE_U_QUERY_RESULT,
                         G_PARAM_READWRITE));
}

GType
query_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (QueryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) query_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (QueryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) query_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "QueryResultType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

enum _querySvcExecuteArgsProperties
{
  PROP_QUERY_SVC_EXECUTE_ARGS_0,
  PROP_QUERY_SVC_EXECUTE_ARGS_QUERY
};

/* reads a query_svc_execute_args object */
static gint32
query_svc_execute_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  querySvcExecuteArgs * this_object = QUERY_SVC_EXECUTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
query_svc_execute_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  querySvcExecuteArgs * this_object = QUERY_SVC_EXECUTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "querySvcExecuteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "query", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->query), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
query_svc_execute_args_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  querySvcExecuteArgs *self = QUERY_SVC_EXECUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_QUERY_SVC_EXECUTE_ARGS_QUERY:
      if (self->query != NULL)
        g_object_unref (self->query);
      self->query = g_value_dup_object (value);
      self->__isset_query = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
query_svc_execute_args_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  querySvcExecuteArgs *self = QUERY_SVC_EXECUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_QUERY_SVC_EXECUTE_ARGS_QUERY:
      g_value_set_object (value, self->query);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
query_svc_execute_args_instance_init (querySvcExecuteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->query = g_object_new (TYPE_QUERY, NULL);
  object->__isset_query = FALSE;
}

static void 
query_svc_execute_args_finalize (GObject *object)
{
  querySvcExecuteArgs *tobject = QUERY_SVC_EXECUTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->query != NULL)
  {
    g_object_unref(tobject->query);
    tobject->query = NULL;
  }
}

static void
query_svc_execute_args_class_init (querySvcExecuteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = query_svc_execute_args_read;
  struct_class->write = query_svc_execute_args_write;

  gobject_class->finalize = query_svc_execute_args_finalize;
  gobject_class->get_property = query_svc_execute_args_get_property;
  gobject_class->set_property = query_svc_execute_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_QUERY_SVC_EXECUTE_ARGS_QUERY,
     g_param_spec_object ("query",
                         NULL,
                         NULL,
                         TYPE_QUERY,
                         G_PARAM_READWRITE));
}

GType
query_svc_execute_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (querySvcExecuteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) query_svc_execute_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (querySvcExecuteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) query_svc_execute_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "querySvcExecuteArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _querySvcExecuteResultProperties
{
  PROP_QUERY_SVC_EXECUTE_RESULT_0,
  PROP_QUERY_SVC_EXECUTE_RESULT_SUCCESS
};

/* reads a query_svc_execute_result object */
static gint32
query_svc_execute_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  querySvcExecuteResult * this_object = QUERY_SVC_EXECUTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
query_svc_execute_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  querySvcExecuteResult * this_object = QUERY_SVC_EXECUTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "querySvcExecuteResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
query_svc_execute_result_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  querySvcExecuteResult *self = QUERY_SVC_EXECUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_QUERY_SVC_EXECUTE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
query_svc_execute_result_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  querySvcExecuteResult *self = QUERY_SVC_EXECUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_QUERY_SVC_EXECUTE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
query_svc_execute_result_instance_init (querySvcExecuteResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_QUERY_RESULT, NULL);
  object->__isset_success = FALSE;
}

static void 
query_svc_execute_result_finalize (GObject *object)
{
  querySvcExecuteResult *tobject = QUERY_SVC_EXECUTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
query_svc_execute_result_class_init (querySvcExecuteResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = query_svc_execute_result_read;
  struct_class->write = query_svc_execute_result_write;

  gobject_class->finalize = query_svc_execute_result_finalize;
  gobject_class->get_property = query_svc_execute_result_get_property;
  gobject_class->set_property = query_svc_execute_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_QUERY_SVC_EXECUTE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_QUERY_RESULT,
                         G_PARAM_READWRITE));
}

GType
query_svc_execute_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (querySvcExecuteResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) query_svc_execute_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (querySvcExecuteResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) query_svc_execute_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "querySvcExecuteResultType",
                                   &type_info, 0);
  }

  return type;
}

