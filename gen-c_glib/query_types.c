/**
 * Autogenerated by Thrift Compiler (0.17.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "query_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *
toString_I_ValueType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case I__VALUE_TYPE_VT_INTEGER:return "I__VALUE_TYPE_VT_INTEGER";
  case I__VALUE_TYPE_VT_STRING:return "I__VALUE_TYPE_VT_STRING";
  case I__VALUE_TYPE_VT_FLOATING:return "I__VALUE_TYPE_VT_FLOATING";
  case I__VALUE_TYPE_VT_BOOLEAN:return "I__VALUE_TYPE_VT_BOOLEAN";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_I_LinkType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case I__LINK_TYPE_LT_TO:return "I__LINK_TYPE_LT_TO";
  case I__LINK_TYPE_LT_FROM:return "I__LINK_TYPE_LT_FROM";
  case I__LINK_TYPE_LT_BOTH:return "I__LINK_TYPE_LT_BOTH";
  case I__LINK_TYPE_LT_ANY:return "I__LINK_TYPE_LT_ANY";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_I_Comparation(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case I__COMPARATION_CMP_GT:return "I__COMPARATION_CMP_GT";
  case I__COMPARATION_CMP_LT:return "I__COMPARATION_CMP_LT";
  case I__COMPARATION_CMP_GE:return "I__COMPARATION_CMP_GE";
  case I__COMPARATION_CMP_LE:return "I__COMPARATION_CMP_LE";
  case I__COMPARATION_CMP_EQ:return "I__COMPARATION_CMP_EQ";
  case I__COMPARATION_CMP_NEQ:return "I__COMPARATION_CMP_NEQ";
  case I__COMPARATION_CMP_CONTAINS:return "I__COMPARATION_CMP_CONTAINS";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_I_ComparableType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case I__COMPARABLE_TYPE_CMPT_FIELD:return "I__COMPARABLE_TYPE_CMPT_FIELD";
  case I__COMPARABLE_TYPE_CMPT_VALUE:return "I__COMPARABLE_TYPE_CMPT_VALUE";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_I_PredicateType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case I__PREDICATE_TYPE_PT_TERM:return "I__PREDICATE_TYPE_PT_TERM";
  case I__PREDICATE_TYPE_PT_OR:return "I__PREDICATE_TYPE_PT_OR";
  case I__PREDICATE_TYPE_PT_AND:return "I__PREDICATE_TYPE_PT_AND";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_I_QueryType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case I__QUERY_TYPE_SCHEMA_CREATE:return "I__QUERY_TYPE_SCHEMA_CREATE";
  case I__QUERY_TYPE_SCHEMA_GET:return "I__QUERY_TYPE_SCHEMA_GET";
  case I__QUERY_TYPE_SCHEMA_GET_ALL:return "I__QUERY_TYPE_SCHEMA_GET_ALL";
  case I__QUERY_TYPE_SCHEMA_DELETE:return "I__QUERY_TYPE_SCHEMA_DELETE";
  case I__QUERY_TYPE_NODE_CREATE:return "I__QUERY_TYPE_NODE_CREATE";
  case I__QUERY_TYPE_NODE_UPDATE:return "I__QUERY_TYPE_NODE_UPDATE";
  case I__QUERY_TYPE_NODE_DELETE:return "I__QUERY_TYPE_NODE_DELETE";
  case I__QUERY_TYPE_NODE_MATCH:return "I__QUERY_TYPE_NODE_MATCH";
  case I__QUERY_TYPE_LINK_CREATE:return "I__QUERY_TYPE_LINK_CREATE";
  case I__QUERY_TYPE_LINK_DELETE:return "I__QUERY_TYPE_LINK_DELETE";
  case I__QUERY_TYPE_MATCH:return "I__QUERY_TYPE_MATCH";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_I_Return(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case I__RETURN_RETURN_NOTHING:return "I__RETURN_RETURN_NOTHING";
  case I__RETURN_RETURN_NODE_FIRST:return "I__RETURN_RETURN_NODE_FIRST";
  case I__RETURN_RETURN_NODE_SECOND:return "I__RETURN_RETURN_NODE_SECOND";
  case I__RETURN_RETURN_LINK:return "I__RETURN_RETURN_LINK";
  case I__RETURN_RETURN_ALL:return "I__RETURN_RETURN_ALL";
  case I__RETURN_RETURN_UNDEF:return "I__RETURN_RETURN_UNDEF";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_I_QueryResultType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case I__QUERY_RESULT_TYPE_RESULT_SCHEMA:return "I__QUERY_RESULT_TYPE_RESULT_SCHEMA";
  case I__QUERY_RESULT_TYPE_RESULT_GENERATOR:return "I__QUERY_RESULT_TYPE_RESULT_GENERATOR";
  case I__QUERY_RESULT_TYPE_RESULT_NONE:return "I__QUERY_RESULT_TYPE_RESULT_NONE";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

enum _I_uValueProperties
{
  PROP_I_U_VALUE_0,
  PROP_I_U_VALUE_INTEGER,
  PROP_I_U_VALUE_STRING_,
  PROP_I_U_VALUE_FLOATING,
  PROP_I_U_VALUE_BOOLEAN
};

/* reads a i_u_value object */
static gint32
i_u_value_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_uValue * this_object = I_U_VALUE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->integer, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_integer = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->string_ != NULL)
          {
            g_free(this_object->string_);
            this_object->string_ = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->string_, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_string_ = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->floating, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_floating = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->boolean, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_boolean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_u_value_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_uValue * this_object = I_U_VALUE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_uValue", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_integer == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "integer", T_I32, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->integer, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_string_ == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "string_", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->string_, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_floating == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "floating", T_DOUBLE, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_double (protocol, this_object->floating, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_boolean == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "boolean", T_BOOL, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->boolean, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_u_value_set_property (GObject *object,
                        guint property_id,
                        const GValue *value,
                        GParamSpec *pspec)
{
  I_uValue *self = I_U_VALUE (object);

  switch (property_id)
  {
    case PROP_I_U_VALUE_INTEGER:
      self->integer = g_value_get_int (value);
      self->__isset_integer = TRUE;
      break;

    case PROP_I_U_VALUE_STRING_:
      if (self->string_ != NULL)
        g_free (self->string_);
      self->string_ = g_value_dup_string (value);
      self->__isset_string_ = TRUE;
      break;

    case PROP_I_U_VALUE_FLOATING:
      self->floating = g_value_get_double (value);
      self->__isset_floating = TRUE;
      break;

    case PROP_I_U_VALUE_BOOLEAN:
      self->boolean = g_value_get_boolean (value);
      self->__isset_boolean = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_u_value_get_property (GObject *object,
                        guint property_id,
                        GValue *value,
                        GParamSpec *pspec)
{
  I_uValue *self = I_U_VALUE (object);

  switch (property_id)
  {
    case PROP_I_U_VALUE_INTEGER:
      g_value_set_int (value, self->integer);
      break;

    case PROP_I_U_VALUE_STRING_:
      g_value_set_string (value, self->string_);
      break;

    case PROP_I_U_VALUE_FLOATING:
      g_value_set_double (value, self->floating);
      break;

    case PROP_I_U_VALUE_BOOLEAN:
      g_value_set_boolean (value, self->boolean);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_u_value_instance_init (I_uValue * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->integer = 0;
  object->__isset_integer = FALSE;
  object->string_ = NULL;
  object->__isset_string_ = FALSE;
  object->floating = 0;
  object->__isset_floating = FALSE;
  object->boolean = 0;
  object->__isset_boolean = FALSE;
}

static void 
i_u_value_finalize (GObject *object)
{
  I_uValue *tobject = I_U_VALUE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->string_ != NULL)
  {
    g_free(tobject->string_);
    tobject->string_ = NULL;
  }
}

static void
i_u_value_class_init (I_uValueClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_u_value_read;
  struct_class->write = i_u_value_write;

  gobject_class->finalize = i_u_value_finalize;
  gobject_class->get_property = i_u_value_get_property;
  gobject_class->set_property = i_u_value_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_U_VALUE_INTEGER,
     g_param_spec_int ("integer",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_U_VALUE_STRING_,
     g_param_spec_string ("string_",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_U_VALUE_FLOATING,
     g_param_spec_double ("floating",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_U_VALUE_BOOLEAN,
     g_param_spec_boolean ("boolean",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
i_u_value_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_uValueClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_u_value_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_uValue),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_u_value_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_uValueType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_ValueProperties
{
  PROP_I__VALUE_0,
  PROP_I__VALUE_TYPE,
  PROP_I__VALUE_VALUE
};

/* reads a i__value object */
static gint32
i__value_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_Value * this_object = I__VALUE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast0;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast0, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (I_ValueType)ecast0;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__value_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_Value * this_object = I__VALUE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_Value", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__value_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  I_Value *self = I__VALUE (object);

  switch (property_id)
  {
    case PROP_I__VALUE_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_I__VALUE_VALUE:
      if (self->value != NULL)
        g_object_unref (self->value);
      self->value = g_value_dup_object (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__value_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  I_Value *self = I__VALUE (object);

  switch (property_id)
  {
    case PROP_I__VALUE_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_I__VALUE_VALUE:
      g_value_set_object (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__value_instance_init (I_Value * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->value = g_object_new (TYPE_I_U_VALUE, NULL);
  object->__isset_value = FALSE;
}

static void 
i__value_finalize (GObject *object)
{
  I_Value *tobject = I__VALUE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->value != NULL)
  {
    g_object_unref(tobject->value);
    tobject->value = NULL;
  }
}

static void
i__value_class_init (I_ValueClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__value_read;
  struct_class->write = i__value_write;

  gobject_class->finalize = i__value_finalize;
  gobject_class->get_property = i__value_get_property;
  gobject_class->set_property = i__value_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__VALUE_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__VALUE_VALUE,
     g_param_spec_object ("value",
                         NULL,
                         NULL,
                         TYPE_I_U_VALUE,
                         G_PARAM_READWRITE));
}

GType
i__value_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_ValueClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__value_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_Value),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__value_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_ValueType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_PropertyProperties
{
  PROP_I__PROPERTY_0,
  PROP_I__PROPERTY_FIELD,
  PROP_I__PROPERTY_VALUE
};

/* reads a i__property object */
static gint32
i__property_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_Property * this_object = I__PROPERTY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->field != NULL)
          {
            g_free(this_object->field);
            this_object->field = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->field, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__property_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_Property * this_object = I__PROPERTY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_Property", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_field == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->field, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__property_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  I_Property *self = I__PROPERTY (object);

  switch (property_id)
  {
    case PROP_I__PROPERTY_FIELD:
      if (self->field != NULL)
        g_free (self->field);
      self->field = g_value_dup_string (value);
      self->__isset_field = TRUE;
      break;

    case PROP_I__PROPERTY_VALUE:
      if (self->value != NULL)
        g_object_unref (self->value);
      self->value = g_value_dup_object (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__property_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  I_Property *self = I__PROPERTY (object);

  switch (property_id)
  {
    case PROP_I__PROPERTY_FIELD:
      g_value_set_string (value, self->field);
      break;

    case PROP_I__PROPERTY_VALUE:
      g_value_set_object (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__property_instance_init (I_Property * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->field = NULL;
  object->__isset_field = FALSE;
  object->value = g_object_new (TYPE_I__VALUE, NULL);
  object->__isset_value = FALSE;
}

static void 
i__property_finalize (GObject *object)
{
  I_Property *tobject = I__PROPERTY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->field != NULL)
  {
    g_free(tobject->field);
    tobject->field = NULL;
  }
  if (tobject->value != NULL)
  {
    g_object_unref(tobject->value);
    tobject->value = NULL;
  }
}

static void
i__property_class_init (I_PropertyClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__property_read;
  struct_class->write = i__property_write;

  gobject_class->finalize = i__property_finalize;
  gobject_class->get_property = i__property_get_property;
  gobject_class->set_property = i__property_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__PROPERTY_FIELD,
     g_param_spec_string ("field",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__PROPERTY_VALUE,
     g_param_spec_object ("value",
                         NULL,
                         NULL,
                         TYPE_I__VALUE,
                         G_PARAM_READWRITE));
}

GType
i__property_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_PropertyClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__property_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_Property),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__property_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_PropertyType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_AttributeProperties
{
  PROP_I__ATTRIBUTE_0,
  PROP_I__ATTRIBUTE_NAME,
  PROP_I__ATTRIBUTE_VT
};

/* reads a i__attribute object */
static gint32
i__attribute_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_Attribute * this_object = I__ATTRIBUTE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast1;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast1, error)) < 0)
            return -1;
          xfer += ret;
          this_object->vt = (I_ValueType)ecast1;
          this_object->__isset_vt = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__attribute_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_Attribute * this_object = I__ATTRIBUTE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_Attribute", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "vt", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->vt, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__attribute_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  I_Attribute *self = I__ATTRIBUTE (object);

  switch (property_id)
  {
    case PROP_I__ATTRIBUTE_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_I__ATTRIBUTE_VT:
      self->vt = g_value_get_int (value);
      self->__isset_vt = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__attribute_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  I_Attribute *self = I__ATTRIBUTE (object);

  switch (property_id)
  {
    case PROP_I__ATTRIBUTE_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_I__ATTRIBUTE_VT:
      g_value_set_int (value, self->vt);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__attribute_instance_init (I_Attribute * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
  object->__isset_vt = FALSE;
}

static void 
i__attribute_finalize (GObject *object)
{
  I_Attribute *tobject = I__ATTRIBUTE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
}

static void
i__attribute_class_init (I_AttributeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__attribute_read;
  struct_class->write = i__attribute_write;

  gobject_class->finalize = i__attribute_finalize;
  gobject_class->get_property = i__attribute_get_property;
  gobject_class->set_property = i__attribute_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__ATTRIBUTE_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__ATTRIBUTE_VT,
     g_param_spec_int ("vt",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));
}

GType
i__attribute_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_AttributeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__attribute_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_Attribute),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__attribute_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_AttributeType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_SchemaProperties
{
  PROP_I__SCHEMA_0,
  PROP_I__SCHEMA_NAME,
  PROP_I__SCHEMA_ATTRIBUTES
};

/* reads a i__schema object */
static gint32
i__schema_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_Schema * this_object = I__SCHEMA(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              I_Attribute * _elem2 = NULL;
              if ( _elem2 != NULL)
              {
                g_object_unref (_elem2);
              }
              _elem2 = g_object_new (TYPE_I__ATTRIBUTE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem2), protocol, error)) < 0)
              {
                g_object_unref (_elem2);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->attributes, _elem2);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__schema_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_Schema * this_object = I__SCHEMA(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_Schema", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i3;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->attributes ? this_object->attributes->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i3 = 0; i3 < (this_object->attributes ? this_object->attributes->len : 0); i3++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->attributes, i3))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__schema_set_property (GObject *object,
                        guint property_id,
                        const GValue *value,
                        GParamSpec *pspec)
{
  I_Schema *self = I__SCHEMA (object);

  switch (property_id)
  {
    case PROP_I__SCHEMA_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_I__SCHEMA_ATTRIBUTES:
      if (self->attributes != NULL)
        g_ptr_array_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__schema_get_property (GObject *object,
                        guint property_id,
                        GValue *value,
                        GParamSpec *pspec)
{
  I_Schema *self = I__SCHEMA (object);

  switch (property_id)
  {
    case PROP_I__SCHEMA_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_I__SCHEMA_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__schema_instance_init (I_Schema * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
  object->attributes = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_attributes = FALSE;
}

static void 
i__schema_finalize (GObject *object)
{
  I_Schema *tobject = I__SCHEMA (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_ptr_array_unref (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
i__schema_class_init (I_SchemaClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__schema_read;
  struct_class->write = i__schema_write;

  gobject_class->finalize = i__schema_finalize;
  gobject_class->get_property = i__schema_get_property;
  gobject_class->set_property = i__schema_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__SCHEMA_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__SCHEMA_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
i__schema_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_SchemaClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__schema_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_Schema),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__schema_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_SchemaType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_NodeProperties
{
  PROP_I__NODE_0,
  PROP_I__NODE_NAME,
  PROP_I__NODE_PROPERTIES
};

/* reads a i__node object */
static gint32
i__node_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_Node * this_object = I__NODE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              I_Property * _elem4 = NULL;
              if ( _elem4 != NULL)
              {
                g_object_unref (_elem4);
              }
              _elem4 = g_object_new (TYPE_I__PROPERTY, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem4), protocol, error)) < 0)
              {
                g_object_unref (_elem4);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->properties, _elem4);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_properties = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__node_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_Node * this_object = I__NODE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_Node", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_name == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "properties", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i5;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->properties ? this_object->properties->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i5 = 0; i5 < (this_object->properties ? this_object->properties->len : 0); i5++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->properties, i5))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__node_set_property (GObject *object,
                      guint property_id,
                      const GValue *value,
                      GParamSpec *pspec)
{
  I_Node *self = I__NODE (object);

  switch (property_id)
  {
    case PROP_I__NODE_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_I__NODE_PROPERTIES:
      if (self->properties != NULL)
        g_ptr_array_unref (self->properties);
      self->properties = g_value_dup_boxed (value);
      self->__isset_properties = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__node_get_property (GObject *object,
                      guint property_id,
                      GValue *value,
                      GParamSpec *pspec)
{
  I_Node *self = I__NODE (object);

  switch (property_id)
  {
    case PROP_I__NODE_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_I__NODE_PROPERTIES:
      g_value_set_boxed (value, self->properties);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__node_instance_init (I_Node * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
  object->properties = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_properties = FALSE;
}

static void 
i__node_finalize (GObject *object)
{
  I_Node *tobject = I__NODE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->properties != NULL)
  {
    g_ptr_array_unref (tobject->properties);
    tobject->properties = NULL;
  }
}

static void
i__node_class_init (I_NodeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__node_read;
  struct_class->write = i__node_write;

  gobject_class->finalize = i__node_finalize;
  gobject_class->get_property = i__node_get_property;
  gobject_class->set_property = i__node_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__NODE_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__NODE_PROPERTIES,
     g_param_spec_boxed ("properties",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
i__node_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_NodeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__node_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_Node),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__node_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_NodeType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_LinkProperties
{
  PROP_I__LINK_0,
  PROP_I__LINK_NAME,
  PROP_I__LINK_TYPE
};

/* reads a i__link object */
static gint32
i__link_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_Link * this_object = I__LINK(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast6;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast6, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (I_LinkType)ecast6;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__link_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_Link * this_object = I__LINK(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_Link", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__link_set_property (GObject *object,
                      guint property_id,
                      const GValue *value,
                      GParamSpec *pspec)
{
  I_Link *self = I__LINK (object);

  switch (property_id)
  {
    case PROP_I__LINK_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_I__LINK_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__link_get_property (GObject *object,
                      guint property_id,
                      GValue *value,
                      GParamSpec *pspec)
{
  I_Link *self = I__LINK (object);

  switch (property_id)
  {
    case PROP_I__LINK_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_I__LINK_TYPE:
      g_value_set_int (value, self->type);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__link_instance_init (I_Link * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
  object->__isset_type = FALSE;
}

static void 
i__link_finalize (GObject *object)
{
  I_Link *tobject = I__LINK (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
}

static void
i__link_class_init (I_LinkClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__link_read;
  struct_class->write = i__link_write;

  gobject_class->finalize = i__link_finalize;
  gobject_class->get_property = i__link_get_property;
  gobject_class->set_property = i__link_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__LINK_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__LINK_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));
}

GType
i__link_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_LinkClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__link_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_Link),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__link_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_LinkType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_uComparableProperties
{
  PROP_I_U_COMPARABLE_0,
  PROP_I_U_COMPARABLE_FIELD_NAME,
  PROP_I_U_COMPARABLE_VALUE
};

/* reads a i_u_comparable object */
static gint32
i_u_comparable_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_uComparable * this_object = I_U_COMPARABLE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->field_name != NULL)
          {
            g_free(this_object->field_name);
            this_object->field_name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->field_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_u_comparable_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_uComparable * this_object = I_U_COMPARABLE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_uComparable", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_field_name == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field_name", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->field_name, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_value == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_u_comparable_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  I_uComparable *self = I_U_COMPARABLE (object);

  switch (property_id)
  {
    case PROP_I_U_COMPARABLE_FIELD_NAME:
      if (self->field_name != NULL)
        g_free (self->field_name);
      self->field_name = g_value_dup_string (value);
      self->__isset_field_name = TRUE;
      break;

    case PROP_I_U_COMPARABLE_VALUE:
      if (self->value != NULL)
        g_object_unref (self->value);
      self->value = g_value_dup_object (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_u_comparable_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  I_uComparable *self = I_U_COMPARABLE (object);

  switch (property_id)
  {
    case PROP_I_U_COMPARABLE_FIELD_NAME:
      g_value_set_string (value, self->field_name);
      break;

    case PROP_I_U_COMPARABLE_VALUE:
      g_value_set_object (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_u_comparable_instance_init (I_uComparable * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->field_name = NULL;
  object->__isset_field_name = FALSE;
  object->value = g_object_new (TYPE_I__VALUE, NULL);
  object->__isset_value = FALSE;
}

static void 
i_u_comparable_finalize (GObject *object)
{
  I_uComparable *tobject = I_U_COMPARABLE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->field_name != NULL)
  {
    g_free(tobject->field_name);
    tobject->field_name = NULL;
  }
  if (tobject->value != NULL)
  {
    g_object_unref(tobject->value);
    tobject->value = NULL;
  }
}

static void
i_u_comparable_class_init (I_uComparableClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_u_comparable_read;
  struct_class->write = i_u_comparable_write;

  gobject_class->finalize = i_u_comparable_finalize;
  gobject_class->get_property = i_u_comparable_get_property;
  gobject_class->set_property = i_u_comparable_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_U_COMPARABLE_FIELD_NAME,
     g_param_spec_string ("field_name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_U_COMPARABLE_VALUE,
     g_param_spec_object ("value",
                         NULL,
                         NULL,
                         TYPE_I__VALUE,
                         G_PARAM_READWRITE));
}

GType
i_u_comparable_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_uComparableClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_u_comparable_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_uComparable),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_u_comparable_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_uComparableType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_ComparableProperties
{
  PROP_I__COMPARABLE_0,
  PROP_I__COMPARABLE_TYPE,
  PROP_I__COMPARABLE_COMPARABLE
};

/* reads a i__comparable object */
static gint32
i__comparable_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_Comparable * this_object = I__COMPARABLE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast7;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast7, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (I_ComparableType)ecast7;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->comparable), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_comparable = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__comparable_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_Comparable * this_object = I__COMPARABLE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_Comparable", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "comparable", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->comparable), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__comparable_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  I_Comparable *self = I__COMPARABLE (object);

  switch (property_id)
  {
    case PROP_I__COMPARABLE_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_I__COMPARABLE_COMPARABLE:
      if (self->comparable != NULL)
        g_object_unref (self->comparable);
      self->comparable = g_value_dup_object (value);
      self->__isset_comparable = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__comparable_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  I_Comparable *self = I__COMPARABLE (object);

  switch (property_id)
  {
    case PROP_I__COMPARABLE_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_I__COMPARABLE_COMPARABLE:
      g_value_set_object (value, self->comparable);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__comparable_instance_init (I_Comparable * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->comparable = g_object_new (TYPE_I_U_COMPARABLE, NULL);
  object->__isset_comparable = FALSE;
}

static void 
i__comparable_finalize (GObject *object)
{
  I_Comparable *tobject = I__COMPARABLE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->comparable != NULL)
  {
    g_object_unref(tobject->comparable);
    tobject->comparable = NULL;
  }
}

static void
i__comparable_class_init (I_ComparableClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__comparable_read;
  struct_class->write = i__comparable_write;

  gobject_class->finalize = i__comparable_finalize;
  gobject_class->get_property = i__comparable_get_property;
  gobject_class->set_property = i__comparable_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__COMPARABLE_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       1,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__COMPARABLE_COMPARABLE,
     g_param_spec_object ("comparable",
                         NULL,
                         NULL,
                         TYPE_I_U_COMPARABLE,
                         G_PARAM_READWRITE));
}

GType
i__comparable_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_ComparableClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__comparable_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_Comparable),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__comparable_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_ComparableType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_CompareProperties
{
  PROP_I__COMPARE_0,
  PROP_I__COMPARE_CMP,
  PROP_I__COMPARE_WITH_
};

/* reads a i__compare object */
static gint32
i__compare_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_Compare * this_object = I__COMPARE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast8;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast8, error)) < 0)
            return -1;
          xfer += ret;
          this_object->cmp = (I_Comparation)ecast8;
          this_object->__isset_cmp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->with_), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_with_ = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__compare_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_Compare * this_object = I__COMPARE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_Compare", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cmp", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->cmp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "with_", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->with_), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__compare_set_property (GObject *object,
                         guint property_id,
                         const GValue *value,
                         GParamSpec *pspec)
{
  I_Compare *self = I__COMPARE (object);

  switch (property_id)
  {
    case PROP_I__COMPARE_CMP:
      self->cmp = g_value_get_int (value);
      self->__isset_cmp = TRUE;
      break;

    case PROP_I__COMPARE_WITH_:
      if (self->with_ != NULL)
        g_object_unref (self->with_);
      self->with_ = g_value_dup_object (value);
      self->__isset_with_ = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__compare_get_property (GObject *object,
                         guint property_id,
                         GValue *value,
                         GParamSpec *pspec)
{
  I_Compare *self = I__COMPARE (object);

  switch (property_id)
  {
    case PROP_I__COMPARE_CMP:
      g_value_set_int (value, self->cmp);
      break;

    case PROP_I__COMPARE_WITH_:
      g_value_set_object (value, self->with_);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__compare_instance_init (I_Compare * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_cmp = FALSE;
  object->with_ = g_object_new (TYPE_I__COMPARABLE, NULL);
  object->__isset_with_ = FALSE;
}

static void 
i__compare_finalize (GObject *object)
{
  I_Compare *tobject = I__COMPARE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->with_ != NULL)
  {
    g_object_unref(tobject->with_);
    tobject->with_ = NULL;
  }
}

static void
i__compare_class_init (I_CompareClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__compare_read;
  struct_class->write = i__compare_write;

  gobject_class->finalize = i__compare_finalize;
  gobject_class->get_property = i__compare_get_property;
  gobject_class->set_property = i__compare_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__COMPARE_CMP,
     g_param_spec_int ("cmp",
                       NULL,
                       NULL,
                       0,
                       6,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__COMPARE_WITH_,
     g_param_spec_object ("with_",
                         NULL,
                         NULL,
                         TYPE_I__COMPARABLE,
                         G_PARAM_READWRITE));
}

GType
i__compare_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_CompareClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__compare_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_Compare),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__compare_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_CompareType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_ConditionCompareProperties
{
  PROP_I__CONDITION_COMPARE_0,
  PROP_I__CONDITION_COMPARE_LEFT,
  PROP_I__CONDITION_COMPARE_COMPARE
};

/* reads a i__condition_compare object */
static gint32
i__condition_compare_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_ConditionCompare * this_object = I__CONDITION_COMPARE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->left), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_left = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->compare), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_compare = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__condition_compare_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_ConditionCompare * this_object = I__CONDITION_COMPARE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_ConditionCompare", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "left", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->left), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "compare", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->compare), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__condition_compare_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  I_ConditionCompare *self = I__CONDITION_COMPARE (object);

  switch (property_id)
  {
    case PROP_I__CONDITION_COMPARE_LEFT:
      if (self->left != NULL)
        g_object_unref (self->left);
      self->left = g_value_dup_object (value);
      self->__isset_left = TRUE;
      break;

    case PROP_I__CONDITION_COMPARE_COMPARE:
      if (self->compare != NULL)
        g_object_unref (self->compare);
      self->compare = g_value_dup_object (value);
      self->__isset_compare = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__condition_compare_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  I_ConditionCompare *self = I__CONDITION_COMPARE (object);

  switch (property_id)
  {
    case PROP_I__CONDITION_COMPARE_LEFT:
      g_value_set_object (value, self->left);
      break;

    case PROP_I__CONDITION_COMPARE_COMPARE:
      g_value_set_object (value, self->compare);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__condition_compare_instance_init (I_ConditionCompare * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->left = g_object_new (TYPE_I__COMPARABLE, NULL);
  object->__isset_left = FALSE;
  object->compare = g_object_new (TYPE_I__COMPARE, NULL);
  object->__isset_compare = FALSE;
}

static void 
i__condition_compare_finalize (GObject *object)
{
  I_ConditionCompare *tobject = I__CONDITION_COMPARE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->left != NULL)
  {
    g_object_unref(tobject->left);
    tobject->left = NULL;
  }
  if (tobject->compare != NULL)
  {
    g_object_unref(tobject->compare);
    tobject->compare = NULL;
  }
}

static void
i__condition_compare_class_init (I_ConditionCompareClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__condition_compare_read;
  struct_class->write = i__condition_compare_write;

  gobject_class->finalize = i__condition_compare_finalize;
  gobject_class->get_property = i__condition_compare_get_property;
  gobject_class->set_property = i__condition_compare_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__CONDITION_COMPARE_LEFT,
     g_param_spec_object ("left",
                         NULL,
                         NULL,
                         TYPE_I__COMPARABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__CONDITION_COMPARE_COMPARE,
     g_param_spec_object ("compare",
                         NULL,
                         NULL,
                         TYPE_I__COMPARE,
                         G_PARAM_READWRITE));
}

GType
i__condition_compare_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_ConditionCompareClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__condition_compare_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_ConditionCompare),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__condition_compare_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_ConditionCompareType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_uPredicateProperties
{
  PROP_I_U_PREDICATE_0,
  PROP_I_U_PREDICATE_TERM,
  PROP_I_U_PREDICATE_AND_,
  PROP_I_U_PREDICATE_OR_
};

/* reads a i_u_predicate object */
static gint32
i_u_predicate_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_uPredicate * this_object = I_U_PREDICATE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->term), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_term = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              I_Predicate * _elem9 = NULL;
              if ( _elem9 != NULL)
              {
                g_object_unref (_elem9);
              }
              _elem9 = g_object_new (TYPE_I__PREDICATE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem9), protocol, error)) < 0)
              {
                g_object_unref (_elem9);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->and_, _elem9);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_and_ = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              I_Predicate * _elem10 = NULL;
              if ( _elem10 != NULL)
              {
                g_object_unref (_elem10);
              }
              _elem10 = g_object_new (TYPE_I__PREDICATE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem10), protocol, error)) < 0)
              {
                g_object_unref (_elem10);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->or_, _elem10);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_or_ = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_u_predicate_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_uPredicate * this_object = I_U_PREDICATE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_uPredicate", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_term == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "term", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->term), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_and_ == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "and_", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i11;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->and_ ? this_object->and_->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i11 = 0; i11 < (this_object->and_ ? this_object->and_->len : 0); i11++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->and_, i11))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_or_ == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "or_", T_LIST, 3, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i12;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->or_ ? this_object->or_->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i12 = 0; i12 < (this_object->or_ ? this_object->or_->len : 0); i12++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->or_, i12))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_u_predicate_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  I_uPredicate *self = I_U_PREDICATE (object);

  switch (property_id)
  {
    case PROP_I_U_PREDICATE_TERM:
      if (self->term != NULL)
        g_object_unref (self->term);
      self->term = g_value_dup_object (value);
      self->__isset_term = TRUE;
      break;

    case PROP_I_U_PREDICATE_AND_:
      if (self->and_ != NULL)
        g_ptr_array_unref (self->and_);
      self->and_ = g_value_dup_boxed (value);
      self->__isset_and_ = TRUE;
      break;

    case PROP_I_U_PREDICATE_OR_:
      if (self->or_ != NULL)
        g_ptr_array_unref (self->or_);
      self->or_ = g_value_dup_boxed (value);
      self->__isset_or_ = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_u_predicate_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  I_uPredicate *self = I_U_PREDICATE (object);

  switch (property_id)
  {
    case PROP_I_U_PREDICATE_TERM:
      g_value_set_object (value, self->term);
      break;

    case PROP_I_U_PREDICATE_AND_:
      g_value_set_boxed (value, self->and_);
      break;

    case PROP_I_U_PREDICATE_OR_:
      g_value_set_boxed (value, self->or_);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_u_predicate_instance_init (I_uPredicate * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->term = g_object_new (TYPE_I__CONDITION_COMPARE, NULL);
  object->__isset_term = FALSE;
  object->and_ = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_and_ = FALSE;
  object->or_ = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_or_ = FALSE;
}

static void 
i_u_predicate_finalize (GObject *object)
{
  I_uPredicate *tobject = I_U_PREDICATE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->term != NULL)
  {
    g_object_unref(tobject->term);
    tobject->term = NULL;
  }
  if (tobject->and_ != NULL)
  {
    g_ptr_array_unref (tobject->and_);
    tobject->and_ = NULL;
  }
  if (tobject->or_ != NULL)
  {
    g_ptr_array_unref (tobject->or_);
    tobject->or_ = NULL;
  }
}

static void
i_u_predicate_class_init (I_uPredicateClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_u_predicate_read;
  struct_class->write = i_u_predicate_write;

  gobject_class->finalize = i_u_predicate_finalize;
  gobject_class->get_property = i_u_predicate_get_property;
  gobject_class->set_property = i_u_predicate_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_U_PREDICATE_TERM,
     g_param_spec_object ("term",
                         NULL,
                         NULL,
                         TYPE_I__CONDITION_COMPARE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_U_PREDICATE_AND_,
     g_param_spec_boxed ("and_",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_U_PREDICATE_OR_,
     g_param_spec_boxed ("or_",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
i_u_predicate_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_uPredicateClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_u_predicate_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_uPredicate),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_u_predicate_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_uPredicateType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_PredicateProperties
{
  PROP_I__PREDICATE_0,
  PROP_I__PREDICATE_TYPE,
  PROP_I__PREDICATE_PREDICATE
};

/* reads a i__predicate object */
static gint32
i__predicate_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_Predicate * this_object = I__PREDICATE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast13;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast13, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (I_PredicateType)ecast13;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->predicate), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_predicate = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__predicate_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_Predicate * this_object = I__PREDICATE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_Predicate", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "predicate", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->predicate), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__predicate_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  I_Predicate *self = I__PREDICATE (object);

  switch (property_id)
  {
    case PROP_I__PREDICATE_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_I__PREDICATE_PREDICATE:
      if (self->predicate != NULL)
        g_object_unref (self->predicate);
      self->predicate = g_value_dup_object (value);
      self->__isset_predicate = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__predicate_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  I_Predicate *self = I__PREDICATE (object);

  switch (property_id)
  {
    case PROP_I__PREDICATE_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_I__PREDICATE_PREDICATE:
      g_value_set_object (value, self->predicate);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__predicate_instance_init (I_Predicate * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->predicate = g_object_new (TYPE_I_U_PREDICATE, NULL);
  object->__isset_predicate = FALSE;
}

static void 
i__predicate_finalize (GObject *object)
{
  I_Predicate *tobject = I__PREDICATE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->predicate != NULL)
  {
    g_object_unref(tobject->predicate);
    tobject->predicate = NULL;
  }
}

static void
i__predicate_class_init (I_PredicateClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__predicate_read;
  struct_class->write = i__predicate_write;

  gobject_class->finalize = i__predicate_finalize;
  gobject_class->get_property = i__predicate_get_property;
  gobject_class->set_property = i__predicate_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__PREDICATE_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       2,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__PREDICATE_PREDICATE,
     g_param_spec_object ("predicate",
                         NULL,
                         NULL,
                         TYPE_I_U_PREDICATE,
                         G_PARAM_READWRITE));
}

GType
i__predicate_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_PredicateClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__predicate_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_Predicate),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__predicate_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_PredicateType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_NodeConditionProperties
{
  PROP_I__NODE_CONDITION_0,
  PROP_I__NODE_CONDITION_IS_NULL,
  PROP_I__NODE_CONDITION_SCHEMA,
  PROP_I__NODE_CONDITION_PREDICATES
};

/* reads a i__node_condition object */
static gint32
i__node_condition_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_NodeCondition * this_object = I__NODE_CONDITION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->is_null, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_is_null = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->schema != NULL)
          {
            g_free(this_object->schema);
            this_object->schema = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->schema, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_schema = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              I_Predicate * _elem14 = NULL;
              if ( _elem14 != NULL)
              {
                g_object_unref (_elem14);
              }
              _elem14 = g_object_new (TYPE_I__PREDICATE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem14), protocol, error)) < 0)
              {
                g_object_unref (_elem14);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->predicates, _elem14);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_predicates = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__node_condition_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_NodeCondition * this_object = I__NODE_CONDITION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_NodeCondition", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "is_null", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->is_null, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "schema", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->schema, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "predicates", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i15;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->predicates ? this_object->predicates->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i15 = 0; i15 < (this_object->predicates ? this_object->predicates->len : 0); i15++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->predicates, i15))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__node_condition_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  I_NodeCondition *self = I__NODE_CONDITION (object);

  switch (property_id)
  {
    case PROP_I__NODE_CONDITION_IS_NULL:
      self->is_null = g_value_get_boolean (value);
      self->__isset_is_null = TRUE;
      break;

    case PROP_I__NODE_CONDITION_SCHEMA:
      if (self->schema != NULL)
        g_free (self->schema);
      self->schema = g_value_dup_string (value);
      self->__isset_schema = TRUE;
      break;

    case PROP_I__NODE_CONDITION_PREDICATES:
      if (self->predicates != NULL)
        g_ptr_array_unref (self->predicates);
      self->predicates = g_value_dup_boxed (value);
      self->__isset_predicates = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__node_condition_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  I_NodeCondition *self = I__NODE_CONDITION (object);

  switch (property_id)
  {
    case PROP_I__NODE_CONDITION_IS_NULL:
      g_value_set_boolean (value, self->is_null);
      break;

    case PROP_I__NODE_CONDITION_SCHEMA:
      g_value_set_string (value, self->schema);
      break;

    case PROP_I__NODE_CONDITION_PREDICATES:
      g_value_set_boxed (value, self->predicates);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__node_condition_instance_init (I_NodeCondition * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->is_null = 0;
  object->__isset_is_null = FALSE;
  object->schema = NULL;
  object->__isset_schema = FALSE;
  object->predicates = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_predicates = FALSE;
}

static void 
i__node_condition_finalize (GObject *object)
{
  I_NodeCondition *tobject = I__NODE_CONDITION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->schema != NULL)
  {
    g_free(tobject->schema);
    tobject->schema = NULL;
  }
  if (tobject->predicates != NULL)
  {
    g_ptr_array_unref (tobject->predicates);
    tobject->predicates = NULL;
  }
}

static void
i__node_condition_class_init (I_NodeConditionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__node_condition_read;
  struct_class->write = i__node_condition_write;

  gobject_class->finalize = i__node_condition_finalize;
  gobject_class->get_property = i__node_condition_get_property;
  gobject_class->set_property = i__node_condition_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__NODE_CONDITION_IS_NULL,
     g_param_spec_boolean ("is_null",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__NODE_CONDITION_SCHEMA,
     g_param_spec_string ("schema",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__NODE_CONDITION_PREDICATES,
     g_param_spec_boxed ("predicates",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
i__node_condition_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_NodeConditionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__node_condition_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_NodeCondition),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__node_condition_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_NodeConditionType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_LinkConditionProperties
{
  PROP_I__LINK_CONDITION_0,
  PROP_I__LINK_CONDITION_IS_NULL,
  PROP_I__LINK_CONDITION_LINK_TYPE,
  PROP_I__LINK_CONDITION_LINK_NAME
};

/* reads a i__link_condition object */
static gint32
i__link_condition_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_LinkCondition * this_object = I__LINK_CONDITION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->is_null, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_is_null = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast16;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast16, error)) < 0)
            return -1;
          xfer += ret;
          this_object->link_type = (I_LinkType)ecast16;
          this_object->__isset_link_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->link_name != NULL)
          {
            g_free(this_object->link_name);
            this_object->link_name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->link_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_link_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__link_condition_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_LinkCondition * this_object = I__LINK_CONDITION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_LinkCondition", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "is_null", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->is_null, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "link_type", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->link_type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "link_name", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->link_name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__link_condition_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  I_LinkCondition *self = I__LINK_CONDITION (object);

  switch (property_id)
  {
    case PROP_I__LINK_CONDITION_IS_NULL:
      self->is_null = g_value_get_boolean (value);
      self->__isset_is_null = TRUE;
      break;

    case PROP_I__LINK_CONDITION_LINK_TYPE:
      self->link_type = g_value_get_int (value);
      self->__isset_link_type = TRUE;
      break;

    case PROP_I__LINK_CONDITION_LINK_NAME:
      if (self->link_name != NULL)
        g_free (self->link_name);
      self->link_name = g_value_dup_string (value);
      self->__isset_link_name = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__link_condition_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  I_LinkCondition *self = I__LINK_CONDITION (object);

  switch (property_id)
  {
    case PROP_I__LINK_CONDITION_IS_NULL:
      g_value_set_boolean (value, self->is_null);
      break;

    case PROP_I__LINK_CONDITION_LINK_TYPE:
      g_value_set_int (value, self->link_type);
      break;

    case PROP_I__LINK_CONDITION_LINK_NAME:
      g_value_set_string (value, self->link_name);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__link_condition_instance_init (I_LinkCondition * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->is_null = 0;
  object->__isset_is_null = FALSE;
  object->__isset_link_type = FALSE;
  object->link_name = NULL;
  object->__isset_link_name = FALSE;
}

static void 
i__link_condition_finalize (GObject *object)
{
  I_LinkCondition *tobject = I__LINK_CONDITION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->link_name != NULL)
  {
    g_free(tobject->link_name);
    tobject->link_name = NULL;
  }
}

static void
i__link_condition_class_init (I_LinkConditionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__link_condition_read;
  struct_class->write = i__link_condition_write;

  gobject_class->finalize = i__link_condition_finalize;
  gobject_class->get_property = i__link_condition_get_property;
  gobject_class->set_property = i__link_condition_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__LINK_CONDITION_IS_NULL,
     g_param_spec_boolean ("is_null",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__LINK_CONDITION_LINK_TYPE,
     g_param_spec_int ("link_type",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__LINK_CONDITION_LINK_NAME,
     g_param_spec_string ("link_name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i__link_condition_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_LinkConditionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__link_condition_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_LinkCondition),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__link_condition_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_LinkConditionType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_MatchConditionProperties
{
  PROP_I__MATCH_CONDITION_0,
  PROP_I__MATCH_CONDITION_IS_NULL,
  PROP_I__MATCH_CONDITION_NODE_FIRST_CONDITION,
  PROP_I__MATCH_CONDITION_NODE_SECOND_CONDITION,
  PROP_I__MATCH_CONDITION_NODE_CROSS_CONDITION,
  PROP_I__MATCH_CONDITION_LINK_CONDITION
};

/* reads a i__match_condition object */
static gint32
i__match_condition_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_MatchCondition * this_object = I__MATCH_CONDITION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->is_null, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_is_null = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->node_first_condition), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_node_first_condition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->node_second_condition), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_node_second_condition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->node_cross_condition), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_node_cross_condition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->link_condition), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_link_condition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__match_condition_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_MatchCondition * this_object = I__MATCH_CONDITION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_MatchCondition", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "is_null", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->is_null, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "node_first_condition", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->node_first_condition), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "node_second_condition", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->node_second_condition), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "node_cross_condition", T_STRUCT, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->node_cross_condition), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "link_condition", T_STRUCT, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->link_condition), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__match_condition_set_property (GObject *object,
                                 guint property_id,
                                 const GValue *value,
                                 GParamSpec *pspec)
{
  I_MatchCondition *self = I__MATCH_CONDITION (object);

  switch (property_id)
  {
    case PROP_I__MATCH_CONDITION_IS_NULL:
      self->is_null = g_value_get_boolean (value);
      self->__isset_is_null = TRUE;
      break;

    case PROP_I__MATCH_CONDITION_NODE_FIRST_CONDITION:
      if (self->node_first_condition != NULL)
        g_object_unref (self->node_first_condition);
      self->node_first_condition = g_value_dup_object (value);
      self->__isset_node_first_condition = TRUE;
      break;

    case PROP_I__MATCH_CONDITION_NODE_SECOND_CONDITION:
      if (self->node_second_condition != NULL)
        g_object_unref (self->node_second_condition);
      self->node_second_condition = g_value_dup_object (value);
      self->__isset_node_second_condition = TRUE;
      break;

    case PROP_I__MATCH_CONDITION_NODE_CROSS_CONDITION:
      if (self->node_cross_condition != NULL)
        g_object_unref (self->node_cross_condition);
      self->node_cross_condition = g_value_dup_object (value);
      self->__isset_node_cross_condition = TRUE;
      break;

    case PROP_I__MATCH_CONDITION_LINK_CONDITION:
      if (self->link_condition != NULL)
        g_object_unref (self->link_condition);
      self->link_condition = g_value_dup_object (value);
      self->__isset_link_condition = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__match_condition_get_property (GObject *object,
                                 guint property_id,
                                 GValue *value,
                                 GParamSpec *pspec)
{
  I_MatchCondition *self = I__MATCH_CONDITION (object);

  switch (property_id)
  {
    case PROP_I__MATCH_CONDITION_IS_NULL:
      g_value_set_boolean (value, self->is_null);
      break;

    case PROP_I__MATCH_CONDITION_NODE_FIRST_CONDITION:
      g_value_set_object (value, self->node_first_condition);
      break;

    case PROP_I__MATCH_CONDITION_NODE_SECOND_CONDITION:
      g_value_set_object (value, self->node_second_condition);
      break;

    case PROP_I__MATCH_CONDITION_NODE_CROSS_CONDITION:
      g_value_set_object (value, self->node_cross_condition);
      break;

    case PROP_I__MATCH_CONDITION_LINK_CONDITION:
      g_value_set_object (value, self->link_condition);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__match_condition_instance_init (I_MatchCondition * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->is_null = 0;
  object->__isset_is_null = FALSE;
  object->node_first_condition = g_object_new (TYPE_I__NODE_CONDITION, NULL);
  object->__isset_node_first_condition = FALSE;
  object->node_second_condition = g_object_new (TYPE_I__NODE_CONDITION, NULL);
  object->__isset_node_second_condition = FALSE;
  object->node_cross_condition = g_object_new (TYPE_I__NODE_CONDITION, NULL);
  object->__isset_node_cross_condition = FALSE;
  object->link_condition = g_object_new (TYPE_I__LINK_CONDITION, NULL);
  object->__isset_link_condition = FALSE;
}

static void 
i__match_condition_finalize (GObject *object)
{
  I_MatchCondition *tobject = I__MATCH_CONDITION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->node_first_condition != NULL)
  {
    g_object_unref(tobject->node_first_condition);
    tobject->node_first_condition = NULL;
  }
  if (tobject->node_second_condition != NULL)
  {
    g_object_unref(tobject->node_second_condition);
    tobject->node_second_condition = NULL;
  }
  if (tobject->node_cross_condition != NULL)
  {
    g_object_unref(tobject->node_cross_condition);
    tobject->node_cross_condition = NULL;
  }
  if (tobject->link_condition != NULL)
  {
    g_object_unref(tobject->link_condition);
    tobject->link_condition = NULL;
  }
}

static void
i__match_condition_class_init (I_MatchConditionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__match_condition_read;
  struct_class->write = i__match_condition_write;

  gobject_class->finalize = i__match_condition_finalize;
  gobject_class->get_property = i__match_condition_get_property;
  gobject_class->set_property = i__match_condition_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__MATCH_CONDITION_IS_NULL,
     g_param_spec_boolean ("is_null",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__MATCH_CONDITION_NODE_FIRST_CONDITION,
     g_param_spec_object ("node_first_condition",
                         NULL,
                         NULL,
                         TYPE_I__NODE_CONDITION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__MATCH_CONDITION_NODE_SECOND_CONDITION,
     g_param_spec_object ("node_second_condition",
                         NULL,
                         NULL,
                         TYPE_I__NODE_CONDITION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__MATCH_CONDITION_NODE_CROSS_CONDITION,
     g_param_spec_object ("node_cross_condition",
                         NULL,
                         NULL,
                         TYPE_I__NODE_CONDITION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__MATCH_CONDITION_LINK_CONDITION,
     g_param_spec_object ("link_condition",
                         NULL,
                         NULL,
                         TYPE_I__LINK_CONDITION,
                         G_PARAM_READWRITE));
}

GType
i__match_condition_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_MatchConditionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__match_condition_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_MatchCondition),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__match_condition_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_MatchConditionType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_SchemaCreateQueryProperties
{
  PROP_I__SCHEMA_CREATE_QUERY_0,
  PROP_I__SCHEMA_CREATE_QUERY_SCHEMA
};

/* reads a i__schema_create_query object */
static gint32
i__schema_create_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_SchemaCreateQuery * this_object = I__SCHEMA_CREATE_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->schema), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_schema = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__schema_create_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_SchemaCreateQuery * this_object = I__SCHEMA_CREATE_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_SchemaCreateQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "schema", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->schema), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__schema_create_query_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  I_SchemaCreateQuery *self = I__SCHEMA_CREATE_QUERY (object);

  switch (property_id)
  {
    case PROP_I__SCHEMA_CREATE_QUERY_SCHEMA:
      if (self->schema != NULL)
        g_object_unref (self->schema);
      self->schema = g_value_dup_object (value);
      self->__isset_schema = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__schema_create_query_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  I_SchemaCreateQuery *self = I__SCHEMA_CREATE_QUERY (object);

  switch (property_id)
  {
    case PROP_I__SCHEMA_CREATE_QUERY_SCHEMA:
      g_value_set_object (value, self->schema);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__schema_create_query_instance_init (I_SchemaCreateQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->schema = g_object_new (TYPE_I__SCHEMA, NULL);
  object->__isset_schema = FALSE;
}

static void 
i__schema_create_query_finalize (GObject *object)
{
  I_SchemaCreateQuery *tobject = I__SCHEMA_CREATE_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->schema != NULL)
  {
    g_object_unref(tobject->schema);
    tobject->schema = NULL;
  }
}

static void
i__schema_create_query_class_init (I_SchemaCreateQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__schema_create_query_read;
  struct_class->write = i__schema_create_query_write;

  gobject_class->finalize = i__schema_create_query_finalize;
  gobject_class->get_property = i__schema_create_query_get_property;
  gobject_class->set_property = i__schema_create_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__SCHEMA_CREATE_QUERY_SCHEMA,
     g_param_spec_object ("schema",
                         NULL,
                         NULL,
                         TYPE_I__SCHEMA,
                         G_PARAM_READWRITE));
}

GType
i__schema_create_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_SchemaCreateQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__schema_create_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_SchemaCreateQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__schema_create_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_SchemaCreateQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_SchemaGetQueryProperties
{
  PROP_I__SCHEMA_GET_QUERY_0,
  PROP_I__SCHEMA_GET_QUERY_SCHEMA_NAME
};

/* reads a i__schema_get_query object */
static gint32
i__schema_get_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_SchemaGetQuery * this_object = I__SCHEMA_GET_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->schema_name != NULL)
          {
            g_free(this_object->schema_name);
            this_object->schema_name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->schema_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_schema_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__schema_get_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_SchemaGetQuery * this_object = I__SCHEMA_GET_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_SchemaGetQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "schema_name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->schema_name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__schema_get_query_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  I_SchemaGetQuery *self = I__SCHEMA_GET_QUERY (object);

  switch (property_id)
  {
    case PROP_I__SCHEMA_GET_QUERY_SCHEMA_NAME:
      if (self->schema_name != NULL)
        g_free (self->schema_name);
      self->schema_name = g_value_dup_string (value);
      self->__isset_schema_name = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__schema_get_query_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  I_SchemaGetQuery *self = I__SCHEMA_GET_QUERY (object);

  switch (property_id)
  {
    case PROP_I__SCHEMA_GET_QUERY_SCHEMA_NAME:
      g_value_set_string (value, self->schema_name);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__schema_get_query_instance_init (I_SchemaGetQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->schema_name = NULL;
  object->__isset_schema_name = FALSE;
}

static void 
i__schema_get_query_finalize (GObject *object)
{
  I_SchemaGetQuery *tobject = I__SCHEMA_GET_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->schema_name != NULL)
  {
    g_free(tobject->schema_name);
    tobject->schema_name = NULL;
  }
}

static void
i__schema_get_query_class_init (I_SchemaGetQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__schema_get_query_read;
  struct_class->write = i__schema_get_query_write;

  gobject_class->finalize = i__schema_get_query_finalize;
  gobject_class->get_property = i__schema_get_query_get_property;
  gobject_class->set_property = i__schema_get_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__SCHEMA_GET_QUERY_SCHEMA_NAME,
     g_param_spec_string ("schema_name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i__schema_get_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_SchemaGetQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__schema_get_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_SchemaGetQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__schema_get_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_SchemaGetQueryType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a i__schema_get_all_query object */
static gint32
i__schema_get_all_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_SchemaGetAllQuery * this_object = I__SCHEMA_GET_ALL_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__schema_get_all_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_SchemaGetAllQuery * this_object = I__SCHEMA_GET_ALL_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_SchemaGetAllQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
i__schema_get_all_query_instance_init (I_SchemaGetAllQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
i__schema_get_all_query_finalize (GObject *object)
{
  I_SchemaGetAllQuery *tobject = I__SCHEMA_GET_ALL_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i__schema_get_all_query_class_init (I_SchemaGetAllQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__schema_get_all_query_read;
  struct_class->write = i__schema_get_all_query_write;

  gobject_class->finalize = i__schema_get_all_query_finalize;
}

GType
i__schema_get_all_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_SchemaGetAllQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__schema_get_all_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_SchemaGetAllQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__schema_get_all_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_SchemaGetAllQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_SchemaDeleteQueryProperties
{
  PROP_I__SCHEMA_DELETE_QUERY_0,
  PROP_I__SCHEMA_DELETE_QUERY_SCHEMA_NAME
};

/* reads a i__schema_delete_query object */
static gint32
i__schema_delete_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_SchemaDeleteQuery * this_object = I__SCHEMA_DELETE_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->schema_name != NULL)
          {
            g_free(this_object->schema_name);
            this_object->schema_name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->schema_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_schema_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__schema_delete_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_SchemaDeleteQuery * this_object = I__SCHEMA_DELETE_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_SchemaDeleteQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "schema_name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->schema_name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__schema_delete_query_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  I_SchemaDeleteQuery *self = I__SCHEMA_DELETE_QUERY (object);

  switch (property_id)
  {
    case PROP_I__SCHEMA_DELETE_QUERY_SCHEMA_NAME:
      if (self->schema_name != NULL)
        g_free (self->schema_name);
      self->schema_name = g_value_dup_string (value);
      self->__isset_schema_name = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__schema_delete_query_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  I_SchemaDeleteQuery *self = I__SCHEMA_DELETE_QUERY (object);

  switch (property_id)
  {
    case PROP_I__SCHEMA_DELETE_QUERY_SCHEMA_NAME:
      g_value_set_string (value, self->schema_name);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__schema_delete_query_instance_init (I_SchemaDeleteQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->schema_name = NULL;
  object->__isset_schema_name = FALSE;
}

static void 
i__schema_delete_query_finalize (GObject *object)
{
  I_SchemaDeleteQuery *tobject = I__SCHEMA_DELETE_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->schema_name != NULL)
  {
    g_free(tobject->schema_name);
    tobject->schema_name = NULL;
  }
}

static void
i__schema_delete_query_class_init (I_SchemaDeleteQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__schema_delete_query_read;
  struct_class->write = i__schema_delete_query_write;

  gobject_class->finalize = i__schema_delete_query_finalize;
  gobject_class->get_property = i__schema_delete_query_get_property;
  gobject_class->set_property = i__schema_delete_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__SCHEMA_DELETE_QUERY_SCHEMA_NAME,
     g_param_spec_string ("schema_name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i__schema_delete_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_SchemaDeleteQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__schema_delete_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_SchemaDeleteQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__schema_delete_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_SchemaDeleteQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_NodeCreateQueryProperties
{
  PROP_I__NODE_CREATE_QUERY_0,
  PROP_I__NODE_CREATE_QUERY_SCHEMA_NAME,
  PROP_I__NODE_CREATE_QUERY_NODE
};

/* reads a i__node_create_query object */
static gint32
i__node_create_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_NodeCreateQuery * this_object = I__NODE_CREATE_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->schema_name != NULL)
          {
            g_free(this_object->schema_name);
            this_object->schema_name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->schema_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_schema_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->node), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_node = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__node_create_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_NodeCreateQuery * this_object = I__NODE_CREATE_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_NodeCreateQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "schema_name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->schema_name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "node", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->node), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__node_create_query_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  I_NodeCreateQuery *self = I__NODE_CREATE_QUERY (object);

  switch (property_id)
  {
    case PROP_I__NODE_CREATE_QUERY_SCHEMA_NAME:
      if (self->schema_name != NULL)
        g_free (self->schema_name);
      self->schema_name = g_value_dup_string (value);
      self->__isset_schema_name = TRUE;
      break;

    case PROP_I__NODE_CREATE_QUERY_NODE:
      if (self->node != NULL)
        g_object_unref (self->node);
      self->node = g_value_dup_object (value);
      self->__isset_node = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__node_create_query_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  I_NodeCreateQuery *self = I__NODE_CREATE_QUERY (object);

  switch (property_id)
  {
    case PROP_I__NODE_CREATE_QUERY_SCHEMA_NAME:
      g_value_set_string (value, self->schema_name);
      break;

    case PROP_I__NODE_CREATE_QUERY_NODE:
      g_value_set_object (value, self->node);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__node_create_query_instance_init (I_NodeCreateQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->schema_name = NULL;
  object->__isset_schema_name = FALSE;
  object->node = g_object_new (TYPE_I__NODE, NULL);
  object->__isset_node = FALSE;
}

static void 
i__node_create_query_finalize (GObject *object)
{
  I_NodeCreateQuery *tobject = I__NODE_CREATE_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->schema_name != NULL)
  {
    g_free(tobject->schema_name);
    tobject->schema_name = NULL;
  }
  if (tobject->node != NULL)
  {
    g_object_unref(tobject->node);
    tobject->node = NULL;
  }
}

static void
i__node_create_query_class_init (I_NodeCreateQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__node_create_query_read;
  struct_class->write = i__node_create_query_write;

  gobject_class->finalize = i__node_create_query_finalize;
  gobject_class->get_property = i__node_create_query_get_property;
  gobject_class->set_property = i__node_create_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__NODE_CREATE_QUERY_SCHEMA_NAME,
     g_param_spec_string ("schema_name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__NODE_CREATE_QUERY_NODE,
     g_param_spec_object ("node",
                         NULL,
                         NULL,
                         TYPE_I__NODE,
                         G_PARAM_READWRITE));
}

GType
i__node_create_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_NodeCreateQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__node_create_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_NodeCreateQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__node_create_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_NodeCreateQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_NodeUpdateQueryProperties
{
  PROP_I__NODE_UPDATE_QUERY_0,
  PROP_I__NODE_UPDATE_QUERY_CONDITION,
  PROP_I__NODE_UPDATE_QUERY_PROPERTIES
};

/* reads a i__node_update_query object */
static gint32
i__node_update_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_NodeUpdateQuery * this_object = I__NODE_UPDATE_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->condition), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_condition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              I_Property * _elem17 = NULL;
              if ( _elem17 != NULL)
              {
                g_object_unref (_elem17);
              }
              _elem17 = g_object_new (TYPE_I__PROPERTY, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem17), protocol, error)) < 0)
              {
                g_object_unref (_elem17);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->properties, _elem17);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_properties = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__node_update_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_NodeUpdateQuery * this_object = I__NODE_UPDATE_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_NodeUpdateQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "condition", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->condition), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "properties", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i18;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->properties ? this_object->properties->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i18 = 0; i18 < (this_object->properties ? this_object->properties->len : 0); i18++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->properties, i18))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__node_update_query_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  I_NodeUpdateQuery *self = I__NODE_UPDATE_QUERY (object);

  switch (property_id)
  {
    case PROP_I__NODE_UPDATE_QUERY_CONDITION:
      if (self->condition != NULL)
        g_object_unref (self->condition);
      self->condition = g_value_dup_object (value);
      self->__isset_condition = TRUE;
      break;

    case PROP_I__NODE_UPDATE_QUERY_PROPERTIES:
      if (self->properties != NULL)
        g_ptr_array_unref (self->properties);
      self->properties = g_value_dup_boxed (value);
      self->__isset_properties = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__node_update_query_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  I_NodeUpdateQuery *self = I__NODE_UPDATE_QUERY (object);

  switch (property_id)
  {
    case PROP_I__NODE_UPDATE_QUERY_CONDITION:
      g_value_set_object (value, self->condition);
      break;

    case PROP_I__NODE_UPDATE_QUERY_PROPERTIES:
      g_value_set_boxed (value, self->properties);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__node_update_query_instance_init (I_NodeUpdateQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->condition = g_object_new (TYPE_I__NODE_CONDITION, NULL);
  object->__isset_condition = FALSE;
  object->properties = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_properties = FALSE;
}

static void 
i__node_update_query_finalize (GObject *object)
{
  I_NodeUpdateQuery *tobject = I__NODE_UPDATE_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->condition != NULL)
  {
    g_object_unref(tobject->condition);
    tobject->condition = NULL;
  }
  if (tobject->properties != NULL)
  {
    g_ptr_array_unref (tobject->properties);
    tobject->properties = NULL;
  }
}

static void
i__node_update_query_class_init (I_NodeUpdateQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__node_update_query_read;
  struct_class->write = i__node_update_query_write;

  gobject_class->finalize = i__node_update_query_finalize;
  gobject_class->get_property = i__node_update_query_get_property;
  gobject_class->set_property = i__node_update_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__NODE_UPDATE_QUERY_CONDITION,
     g_param_spec_object ("condition",
                         NULL,
                         NULL,
                         TYPE_I__NODE_CONDITION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__NODE_UPDATE_QUERY_PROPERTIES,
     g_param_spec_boxed ("properties",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
i__node_update_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_NodeUpdateQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__node_update_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_NodeUpdateQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__node_update_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_NodeUpdateQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_NodeDeleteQueryProperties
{
  PROP_I__NODE_DELETE_QUERY_0,
  PROP_I__NODE_DELETE_QUERY_CONDITION
};

/* reads a i__node_delete_query object */
static gint32
i__node_delete_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_NodeDeleteQuery * this_object = I__NODE_DELETE_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->condition), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_condition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__node_delete_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_NodeDeleteQuery * this_object = I__NODE_DELETE_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_NodeDeleteQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "condition", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->condition), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__node_delete_query_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  I_NodeDeleteQuery *self = I__NODE_DELETE_QUERY (object);

  switch (property_id)
  {
    case PROP_I__NODE_DELETE_QUERY_CONDITION:
      if (self->condition != NULL)
        g_object_unref (self->condition);
      self->condition = g_value_dup_object (value);
      self->__isset_condition = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__node_delete_query_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  I_NodeDeleteQuery *self = I__NODE_DELETE_QUERY (object);

  switch (property_id)
  {
    case PROP_I__NODE_DELETE_QUERY_CONDITION:
      g_value_set_object (value, self->condition);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__node_delete_query_instance_init (I_NodeDeleteQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->condition = g_object_new (TYPE_I__NODE_CONDITION, NULL);
  object->__isset_condition = FALSE;
}

static void 
i__node_delete_query_finalize (GObject *object)
{
  I_NodeDeleteQuery *tobject = I__NODE_DELETE_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->condition != NULL)
  {
    g_object_unref(tobject->condition);
    tobject->condition = NULL;
  }
}

static void
i__node_delete_query_class_init (I_NodeDeleteQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__node_delete_query_read;
  struct_class->write = i__node_delete_query_write;

  gobject_class->finalize = i__node_delete_query_finalize;
  gobject_class->get_property = i__node_delete_query_get_property;
  gobject_class->set_property = i__node_delete_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__NODE_DELETE_QUERY_CONDITION,
     g_param_spec_object ("condition",
                         NULL,
                         NULL,
                         TYPE_I__NODE_CONDITION,
                         G_PARAM_READWRITE));
}

GType
i__node_delete_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_NodeDeleteQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__node_delete_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_NodeDeleteQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__node_delete_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_NodeDeleteQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_NodeMatchQueryProperties
{
  PROP_I__NODE_MATCH_QUERY_0,
  PROP_I__NODE_MATCH_QUERY_CONDITION
};

/* reads a i__node_match_query object */
static gint32
i__node_match_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_NodeMatchQuery * this_object = I__NODE_MATCH_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->condition), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_condition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__node_match_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_NodeMatchQuery * this_object = I__NODE_MATCH_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_NodeMatchQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "condition", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->condition), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__node_match_query_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  I_NodeMatchQuery *self = I__NODE_MATCH_QUERY (object);

  switch (property_id)
  {
    case PROP_I__NODE_MATCH_QUERY_CONDITION:
      if (self->condition != NULL)
        g_object_unref (self->condition);
      self->condition = g_value_dup_object (value);
      self->__isset_condition = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__node_match_query_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  I_NodeMatchQuery *self = I__NODE_MATCH_QUERY (object);

  switch (property_id)
  {
    case PROP_I__NODE_MATCH_QUERY_CONDITION:
      g_value_set_object (value, self->condition);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__node_match_query_instance_init (I_NodeMatchQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->condition = g_object_new (TYPE_I__NODE_CONDITION, NULL);
  object->__isset_condition = FALSE;
}

static void 
i__node_match_query_finalize (GObject *object)
{
  I_NodeMatchQuery *tobject = I__NODE_MATCH_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->condition != NULL)
  {
    g_object_unref(tobject->condition);
    tobject->condition = NULL;
  }
}

static void
i__node_match_query_class_init (I_NodeMatchQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__node_match_query_read;
  struct_class->write = i__node_match_query_write;

  gobject_class->finalize = i__node_match_query_finalize;
  gobject_class->get_property = i__node_match_query_get_property;
  gobject_class->set_property = i__node_match_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__NODE_MATCH_QUERY_CONDITION,
     g_param_spec_object ("condition",
                         NULL,
                         NULL,
                         TYPE_I__NODE_CONDITION,
                         G_PARAM_READWRITE));
}

GType
i__node_match_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_NodeMatchQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__node_match_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_NodeMatchQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__node_match_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_NodeMatchQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_LinkCreateQueryProperties
{
  PROP_I__LINK_CREATE_QUERY_0,
  PROP_I__LINK_CREATE_QUERY_LINK_NAME,
  PROP_I__LINK_CREATE_QUERY_LINK_TYPE,
  PROP_I__LINK_CREATE_QUERY_FIRST,
  PROP_I__LINK_CREATE_QUERY_SECOND
};

/* reads a i__link_create_query object */
static gint32
i__link_create_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_LinkCreateQuery * this_object = I__LINK_CREATE_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->link_name != NULL)
          {
            g_free(this_object->link_name);
            this_object->link_name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->link_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_link_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast19;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast19, error)) < 0)
            return -1;
          xfer += ret;
          this_object->link_type = (I_LinkType)ecast19;
          this_object->__isset_link_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->first), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_first = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->second), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_second = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__link_create_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_LinkCreateQuery * this_object = I__LINK_CREATE_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_LinkCreateQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "link_name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->link_name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "link_type", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->link_type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "first", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->first), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "second", T_STRUCT, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->second), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__link_create_query_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  I_LinkCreateQuery *self = I__LINK_CREATE_QUERY (object);

  switch (property_id)
  {
    case PROP_I__LINK_CREATE_QUERY_LINK_NAME:
      if (self->link_name != NULL)
        g_free (self->link_name);
      self->link_name = g_value_dup_string (value);
      self->__isset_link_name = TRUE;
      break;

    case PROP_I__LINK_CREATE_QUERY_LINK_TYPE:
      self->link_type = g_value_get_int (value);
      self->__isset_link_type = TRUE;
      break;

    case PROP_I__LINK_CREATE_QUERY_FIRST:
      if (self->first != NULL)
        g_object_unref (self->first);
      self->first = g_value_dup_object (value);
      self->__isset_first = TRUE;
      break;

    case PROP_I__LINK_CREATE_QUERY_SECOND:
      if (self->second != NULL)
        g_object_unref (self->second);
      self->second = g_value_dup_object (value);
      self->__isset_second = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__link_create_query_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  I_LinkCreateQuery *self = I__LINK_CREATE_QUERY (object);

  switch (property_id)
  {
    case PROP_I__LINK_CREATE_QUERY_LINK_NAME:
      g_value_set_string (value, self->link_name);
      break;

    case PROP_I__LINK_CREATE_QUERY_LINK_TYPE:
      g_value_set_int (value, self->link_type);
      break;

    case PROP_I__LINK_CREATE_QUERY_FIRST:
      g_value_set_object (value, self->first);
      break;

    case PROP_I__LINK_CREATE_QUERY_SECOND:
      g_value_set_object (value, self->second);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__link_create_query_instance_init (I_LinkCreateQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->link_name = NULL;
  object->__isset_link_name = FALSE;
  object->__isset_link_type = FALSE;
  object->first = g_object_new (TYPE_I__NODE_CONDITION, NULL);
  object->__isset_first = FALSE;
  object->second = g_object_new (TYPE_I__NODE_CONDITION, NULL);
  object->__isset_second = FALSE;
}

static void 
i__link_create_query_finalize (GObject *object)
{
  I_LinkCreateQuery *tobject = I__LINK_CREATE_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->link_name != NULL)
  {
    g_free(tobject->link_name);
    tobject->link_name = NULL;
  }
  if (tobject->first != NULL)
  {
    g_object_unref(tobject->first);
    tobject->first = NULL;
  }
  if (tobject->second != NULL)
  {
    g_object_unref(tobject->second);
    tobject->second = NULL;
  }
}

static void
i__link_create_query_class_init (I_LinkCreateQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__link_create_query_read;
  struct_class->write = i__link_create_query_write;

  gobject_class->finalize = i__link_create_query_finalize;
  gobject_class->get_property = i__link_create_query_get_property;
  gobject_class->set_property = i__link_create_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__LINK_CREATE_QUERY_LINK_NAME,
     g_param_spec_string ("link_name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__LINK_CREATE_QUERY_LINK_TYPE,
     g_param_spec_int ("link_type",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__LINK_CREATE_QUERY_FIRST,
     g_param_spec_object ("first",
                         NULL,
                         NULL,
                         TYPE_I__NODE_CONDITION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__LINK_CREATE_QUERY_SECOND,
     g_param_spec_object ("second",
                         NULL,
                         NULL,
                         TYPE_I__NODE_CONDITION,
                         G_PARAM_READWRITE));
}

GType
i__link_create_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_LinkCreateQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__link_create_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_LinkCreateQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__link_create_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_LinkCreateQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_LinkDeleteQueryProperties
{
  PROP_I__LINK_DELETE_QUERY_0,
  PROP_I__LINK_DELETE_QUERY_CONDITION
};

/* reads a i__link_delete_query object */
static gint32
i__link_delete_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_LinkDeleteQuery * this_object = I__LINK_DELETE_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->condition), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_condition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__link_delete_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_LinkDeleteQuery * this_object = I__LINK_DELETE_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_LinkDeleteQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "condition", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->condition), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__link_delete_query_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  I_LinkDeleteQuery *self = I__LINK_DELETE_QUERY (object);

  switch (property_id)
  {
    case PROP_I__LINK_DELETE_QUERY_CONDITION:
      if (self->condition != NULL)
        g_object_unref (self->condition);
      self->condition = g_value_dup_object (value);
      self->__isset_condition = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__link_delete_query_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  I_LinkDeleteQuery *self = I__LINK_DELETE_QUERY (object);

  switch (property_id)
  {
    case PROP_I__LINK_DELETE_QUERY_CONDITION:
      g_value_set_object (value, self->condition);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__link_delete_query_instance_init (I_LinkDeleteQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->condition = g_object_new (TYPE_I__MATCH_CONDITION, NULL);
  object->__isset_condition = FALSE;
}

static void 
i__link_delete_query_finalize (GObject *object)
{
  I_LinkDeleteQuery *tobject = I__LINK_DELETE_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->condition != NULL)
  {
    g_object_unref(tobject->condition);
    tobject->condition = NULL;
  }
}

static void
i__link_delete_query_class_init (I_LinkDeleteQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__link_delete_query_read;
  struct_class->write = i__link_delete_query_write;

  gobject_class->finalize = i__link_delete_query_finalize;
  gobject_class->get_property = i__link_delete_query_get_property;
  gobject_class->set_property = i__link_delete_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__LINK_DELETE_QUERY_CONDITION,
     g_param_spec_object ("condition",
                         NULL,
                         NULL,
                         TYPE_I__MATCH_CONDITION,
                         G_PARAM_READWRITE));
}

GType
i__link_delete_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_LinkDeleteQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__link_delete_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_LinkDeleteQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__link_delete_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_LinkDeleteQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_MatchQueryProperties
{
  PROP_I__MATCH_QUERY_0,
  PROP_I__MATCH_QUERY_CONDITION
};

/* reads a i__match_query object */
static gint32
i__match_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_MatchQuery * this_object = I__MATCH_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->condition), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_condition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__match_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_MatchQuery * this_object = I__MATCH_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_MatchQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "condition", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->condition), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__match_query_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  I_MatchQuery *self = I__MATCH_QUERY (object);

  switch (property_id)
  {
    case PROP_I__MATCH_QUERY_CONDITION:
      if (self->condition != NULL)
        g_object_unref (self->condition);
      self->condition = g_value_dup_object (value);
      self->__isset_condition = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__match_query_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  I_MatchQuery *self = I__MATCH_QUERY (object);

  switch (property_id)
  {
    case PROP_I__MATCH_QUERY_CONDITION:
      g_value_set_object (value, self->condition);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__match_query_instance_init (I_MatchQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->condition = g_object_new (TYPE_I__MATCH_CONDITION, NULL);
  object->__isset_condition = FALSE;
}

static void 
i__match_query_finalize (GObject *object)
{
  I_MatchQuery *tobject = I__MATCH_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->condition != NULL)
  {
    g_object_unref(tobject->condition);
    tobject->condition = NULL;
  }
}

static void
i__match_query_class_init (I_MatchQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__match_query_read;
  struct_class->write = i__match_query_write;

  gobject_class->finalize = i__match_query_finalize;
  gobject_class->get_property = i__match_query_get_property;
  gobject_class->set_property = i__match_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__MATCH_QUERY_CONDITION,
     g_param_spec_object ("condition",
                         NULL,
                         NULL,
                         TYPE_I__MATCH_CONDITION,
                         G_PARAM_READWRITE));
}

GType
i__match_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_MatchQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__match_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_MatchQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__match_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_MatchQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_uQueryProperties
{
  PROP_I_U_QUERY_0,
  PROP_I_U_QUERY_SCHEMA_CREATE_QUERY,
  PROP_I_U_QUERY_SCHEMA_GET_QUERY,
  PROP_I_U_QUERY_SCHEMA_GET_ALL_QUERY,
  PROP_I_U_QUERY_SCHEMA_DELETE_QUERY,
  PROP_I_U_QUERY_NODE_CREATE_QUERY,
  PROP_I_U_QUERY_NODE_UPDATE_QUERY,
  PROP_I_U_QUERY_NODE_DELETE_QUERY,
  PROP_I_U_QUERY_NODE_MATCH_QUERY,
  PROP_I_U_QUERY_LINK_CREATE_QUERY,
  PROP_I_U_QUERY_LINK_DELETE_QUERY,
  PROP_I_U_QUERY_MATCH_QUERY
};

/* reads a i_u_query object */
static gint32
i_u_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_uQuery * this_object = I_U_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->schema_create_query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_schema_create_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->schema_get_query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_schema_get_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->schema_get_all_query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_schema_get_all_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->schema_delete_query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_schema_delete_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->node_create_query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_node_create_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->node_update_query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_node_update_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->node_delete_query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_node_delete_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->node_match_query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_node_match_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->link_create_query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_link_create_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->link_delete_query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_link_delete_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->match_query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_match_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_u_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_uQuery * this_object = I_U_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_uQuery", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_schema_create_query == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "schema_create_query", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->schema_create_query), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_schema_get_query == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "schema_get_query", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->schema_get_query), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_schema_get_all_query == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "schema_get_all_query", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->schema_get_all_query), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_schema_delete_query == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "schema_delete_query", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->schema_delete_query), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_node_create_query == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "node_create_query", T_STRUCT, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->node_create_query), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_node_update_query == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "node_update_query", T_STRUCT, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->node_update_query), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_node_delete_query == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "node_delete_query", T_STRUCT, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->node_delete_query), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_node_match_query == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "node_match_query", T_STRUCT, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->node_match_query), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_link_create_query == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "link_create_query", T_STRUCT, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->link_create_query), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_link_delete_query == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "link_delete_query", T_STRUCT, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->link_delete_query), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_match_query == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "match_query", T_STRUCT, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->match_query), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_u_query_set_property (GObject *object,
                        guint property_id,
                        const GValue *value,
                        GParamSpec *pspec)
{
  I_uQuery *self = I_U_QUERY (object);

  switch (property_id)
  {
    case PROP_I_U_QUERY_SCHEMA_CREATE_QUERY:
      if (self->schema_create_query != NULL)
        g_object_unref (self->schema_create_query);
      self->schema_create_query = g_value_dup_object (value);
      self->__isset_schema_create_query = TRUE;
      break;

    case PROP_I_U_QUERY_SCHEMA_GET_QUERY:
      if (self->schema_get_query != NULL)
        g_object_unref (self->schema_get_query);
      self->schema_get_query = g_value_dup_object (value);
      self->__isset_schema_get_query = TRUE;
      break;

    case PROP_I_U_QUERY_SCHEMA_GET_ALL_QUERY:
      if (self->schema_get_all_query != NULL)
        g_object_unref (self->schema_get_all_query);
      self->schema_get_all_query = g_value_dup_object (value);
      self->__isset_schema_get_all_query = TRUE;
      break;

    case PROP_I_U_QUERY_SCHEMA_DELETE_QUERY:
      if (self->schema_delete_query != NULL)
        g_object_unref (self->schema_delete_query);
      self->schema_delete_query = g_value_dup_object (value);
      self->__isset_schema_delete_query = TRUE;
      break;

    case PROP_I_U_QUERY_NODE_CREATE_QUERY:
      if (self->node_create_query != NULL)
        g_object_unref (self->node_create_query);
      self->node_create_query = g_value_dup_object (value);
      self->__isset_node_create_query = TRUE;
      break;

    case PROP_I_U_QUERY_NODE_UPDATE_QUERY:
      if (self->node_update_query != NULL)
        g_object_unref (self->node_update_query);
      self->node_update_query = g_value_dup_object (value);
      self->__isset_node_update_query = TRUE;
      break;

    case PROP_I_U_QUERY_NODE_DELETE_QUERY:
      if (self->node_delete_query != NULL)
        g_object_unref (self->node_delete_query);
      self->node_delete_query = g_value_dup_object (value);
      self->__isset_node_delete_query = TRUE;
      break;

    case PROP_I_U_QUERY_NODE_MATCH_QUERY:
      if (self->node_match_query != NULL)
        g_object_unref (self->node_match_query);
      self->node_match_query = g_value_dup_object (value);
      self->__isset_node_match_query = TRUE;
      break;

    case PROP_I_U_QUERY_LINK_CREATE_QUERY:
      if (self->link_create_query != NULL)
        g_object_unref (self->link_create_query);
      self->link_create_query = g_value_dup_object (value);
      self->__isset_link_create_query = TRUE;
      break;

    case PROP_I_U_QUERY_LINK_DELETE_QUERY:
      if (self->link_delete_query != NULL)
        g_object_unref (self->link_delete_query);
      self->link_delete_query = g_value_dup_object (value);
      self->__isset_link_delete_query = TRUE;
      break;

    case PROP_I_U_QUERY_MATCH_QUERY:
      if (self->match_query != NULL)
        g_object_unref (self->match_query);
      self->match_query = g_value_dup_object (value);
      self->__isset_match_query = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_u_query_get_property (GObject *object,
                        guint property_id,
                        GValue *value,
                        GParamSpec *pspec)
{
  I_uQuery *self = I_U_QUERY (object);

  switch (property_id)
  {
    case PROP_I_U_QUERY_SCHEMA_CREATE_QUERY:
      g_value_set_object (value, self->schema_create_query);
      break;

    case PROP_I_U_QUERY_SCHEMA_GET_QUERY:
      g_value_set_object (value, self->schema_get_query);
      break;

    case PROP_I_U_QUERY_SCHEMA_GET_ALL_QUERY:
      g_value_set_object (value, self->schema_get_all_query);
      break;

    case PROP_I_U_QUERY_SCHEMA_DELETE_QUERY:
      g_value_set_object (value, self->schema_delete_query);
      break;

    case PROP_I_U_QUERY_NODE_CREATE_QUERY:
      g_value_set_object (value, self->node_create_query);
      break;

    case PROP_I_U_QUERY_NODE_UPDATE_QUERY:
      g_value_set_object (value, self->node_update_query);
      break;

    case PROP_I_U_QUERY_NODE_DELETE_QUERY:
      g_value_set_object (value, self->node_delete_query);
      break;

    case PROP_I_U_QUERY_NODE_MATCH_QUERY:
      g_value_set_object (value, self->node_match_query);
      break;

    case PROP_I_U_QUERY_LINK_CREATE_QUERY:
      g_value_set_object (value, self->link_create_query);
      break;

    case PROP_I_U_QUERY_LINK_DELETE_QUERY:
      g_value_set_object (value, self->link_delete_query);
      break;

    case PROP_I_U_QUERY_MATCH_QUERY:
      g_value_set_object (value, self->match_query);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_u_query_instance_init (I_uQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->schema_create_query = g_object_new (TYPE_I__SCHEMA_CREATE_QUERY, NULL);
  object->__isset_schema_create_query = FALSE;
  object->schema_get_query = g_object_new (TYPE_I__SCHEMA_GET_QUERY, NULL);
  object->__isset_schema_get_query = FALSE;
  object->schema_get_all_query = g_object_new (TYPE_I__SCHEMA_GET_ALL_QUERY, NULL);
  object->__isset_schema_get_all_query = FALSE;
  object->schema_delete_query = g_object_new (TYPE_I__SCHEMA_DELETE_QUERY, NULL);
  object->__isset_schema_delete_query = FALSE;
  object->node_create_query = g_object_new (TYPE_I__NODE_CREATE_QUERY, NULL);
  object->__isset_node_create_query = FALSE;
  object->node_update_query = g_object_new (TYPE_I__NODE_UPDATE_QUERY, NULL);
  object->__isset_node_update_query = FALSE;
  object->node_delete_query = g_object_new (TYPE_I__NODE_DELETE_QUERY, NULL);
  object->__isset_node_delete_query = FALSE;
  object->node_match_query = g_object_new (TYPE_I__NODE_MATCH_QUERY, NULL);
  object->__isset_node_match_query = FALSE;
  object->link_create_query = g_object_new (TYPE_I__LINK_CREATE_QUERY, NULL);
  object->__isset_link_create_query = FALSE;
  object->link_delete_query = g_object_new (TYPE_I__LINK_DELETE_QUERY, NULL);
  object->__isset_link_delete_query = FALSE;
  object->match_query = g_object_new (TYPE_I__MATCH_QUERY, NULL);
  object->__isset_match_query = FALSE;
}

static void 
i_u_query_finalize (GObject *object)
{
  I_uQuery *tobject = I_U_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->schema_create_query != NULL)
  {
    g_object_unref(tobject->schema_create_query);
    tobject->schema_create_query = NULL;
  }
  if (tobject->schema_get_query != NULL)
  {
    g_object_unref(tobject->schema_get_query);
    tobject->schema_get_query = NULL;
  }
  if (tobject->schema_get_all_query != NULL)
  {
    g_object_unref(tobject->schema_get_all_query);
    tobject->schema_get_all_query = NULL;
  }
  if (tobject->schema_delete_query != NULL)
  {
    g_object_unref(tobject->schema_delete_query);
    tobject->schema_delete_query = NULL;
  }
  if (tobject->node_create_query != NULL)
  {
    g_object_unref(tobject->node_create_query);
    tobject->node_create_query = NULL;
  }
  if (tobject->node_update_query != NULL)
  {
    g_object_unref(tobject->node_update_query);
    tobject->node_update_query = NULL;
  }
  if (tobject->node_delete_query != NULL)
  {
    g_object_unref(tobject->node_delete_query);
    tobject->node_delete_query = NULL;
  }
  if (tobject->node_match_query != NULL)
  {
    g_object_unref(tobject->node_match_query);
    tobject->node_match_query = NULL;
  }
  if (tobject->link_create_query != NULL)
  {
    g_object_unref(tobject->link_create_query);
    tobject->link_create_query = NULL;
  }
  if (tobject->link_delete_query != NULL)
  {
    g_object_unref(tobject->link_delete_query);
    tobject->link_delete_query = NULL;
  }
  if (tobject->match_query != NULL)
  {
    g_object_unref(tobject->match_query);
    tobject->match_query = NULL;
  }
}

static void
i_u_query_class_init (I_uQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_u_query_read;
  struct_class->write = i_u_query_write;

  gobject_class->finalize = i_u_query_finalize;
  gobject_class->get_property = i_u_query_get_property;
  gobject_class->set_property = i_u_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_U_QUERY_SCHEMA_CREATE_QUERY,
     g_param_spec_object ("schema_create_query",
                         NULL,
                         NULL,
                         TYPE_I__SCHEMA_CREATE_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_U_QUERY_SCHEMA_GET_QUERY,
     g_param_spec_object ("schema_get_query",
                         NULL,
                         NULL,
                         TYPE_I__SCHEMA_GET_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_U_QUERY_SCHEMA_GET_ALL_QUERY,
     g_param_spec_object ("schema_get_all_query",
                         NULL,
                         NULL,
                         TYPE_I__SCHEMA_GET_ALL_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_U_QUERY_SCHEMA_DELETE_QUERY,
     g_param_spec_object ("schema_delete_query",
                         NULL,
                         NULL,
                         TYPE_I__SCHEMA_DELETE_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_U_QUERY_NODE_CREATE_QUERY,
     g_param_spec_object ("node_create_query",
                         NULL,
                         NULL,
                         TYPE_I__NODE_CREATE_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_U_QUERY_NODE_UPDATE_QUERY,
     g_param_spec_object ("node_update_query",
                         NULL,
                         NULL,
                         TYPE_I__NODE_UPDATE_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_U_QUERY_NODE_DELETE_QUERY,
     g_param_spec_object ("node_delete_query",
                         NULL,
                         NULL,
                         TYPE_I__NODE_DELETE_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_U_QUERY_NODE_MATCH_QUERY,
     g_param_spec_object ("node_match_query",
                         NULL,
                         NULL,
                         TYPE_I__NODE_MATCH_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_U_QUERY_LINK_CREATE_QUERY,
     g_param_spec_object ("link_create_query",
                         NULL,
                         NULL,
                         TYPE_I__LINK_CREATE_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_U_QUERY_LINK_DELETE_QUERY,
     g_param_spec_object ("link_delete_query",
                         NULL,
                         NULL,
                         TYPE_I__LINK_DELETE_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_U_QUERY_MATCH_QUERY,
     g_param_spec_object ("match_query",
                         NULL,
                         NULL,
                         TYPE_I__MATCH_QUERY,
                         G_PARAM_READWRITE));
}

GType
i_u_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_uQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_u_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_uQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_u_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_uQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_QueryProperties
{
  PROP_I__QUERY_0,
  PROP_I__QUERY_TYPE,
  PROP_I__QUERY_QUERY
};

/* reads a i__query object */
static gint32
i__query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_Query * this_object = I__QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast20;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast20, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (I_QueryType)ecast20;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_Query * this_object = I__QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_Query", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "query", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->query), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__query_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  I_Query *self = I__QUERY (object);

  switch (property_id)
  {
    case PROP_I__QUERY_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_I__QUERY_QUERY:
      if (self->query != NULL)
        g_object_unref (self->query);
      self->query = g_value_dup_object (value);
      self->__isset_query = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__query_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  I_Query *self = I__QUERY (object);

  switch (property_id)
  {
    case PROP_I__QUERY_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_I__QUERY_QUERY:
      g_value_set_object (value, self->query);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__query_instance_init (I_Query * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->query = g_object_new (TYPE_I_U_QUERY, NULL);
  object->__isset_query = FALSE;
}

static void 
i__query_finalize (GObject *object)
{
  I_Query *tobject = I__QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->query != NULL)
  {
    g_object_unref(tobject->query);
    tobject->query = NULL;
  }
}

static void
i__query_class_init (I_QueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__query_read;
  struct_class->write = i__query_write;

  gobject_class->finalize = i__query_finalize;
  gobject_class->get_property = i__query_get_property;
  gobject_class->set_property = i__query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__QUERY_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       10,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__QUERY_QUERY,
     g_param_spec_object ("query",
                         NULL,
                         NULL,
                         TYPE_I_U_QUERY,
                         G_PARAM_READWRITE));
}

GType
i__query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_QueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_Query),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_QueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_ResultProperties
{
  PROP_I__RESULT_0,
  PROP_I__RESULT_RETURN_ITEMS,
  PROP_I__RESULT_FIRST,
  PROP_I__RESULT_LINK,
  PROP_I__RESULT_SECOND,
  PROP_I__RESULT_SCHEMA
};

/* reads a i__result object */
static gint32
i__result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_Result * this_object = I__RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast21;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast21, error)) < 0)
            return -1;
          xfer += ret;
          this_object->return_items = (I_Return)ecast21;
          this_object->__isset_return_items = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->first), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_first = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->link), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_link = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->second), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_second = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->schema), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_schema = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_Result * this_object = I__RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_Result", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "return_items", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->return_items, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_first == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "first", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->first), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_link == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "link", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->link), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_second == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "second", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->second), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_schema == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "schema", T_STRUCT, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->schema), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__result_set_property (GObject *object,
                        guint property_id,
                        const GValue *value,
                        GParamSpec *pspec)
{
  I_Result *self = I__RESULT (object);

  switch (property_id)
  {
    case PROP_I__RESULT_RETURN_ITEMS:
      self->return_items = g_value_get_int (value);
      self->__isset_return_items = TRUE;
      break;

    case PROP_I__RESULT_FIRST:
      if (self->first != NULL)
        g_object_unref (self->first);
      self->first = g_value_dup_object (value);
      self->__isset_first = TRUE;
      break;

    case PROP_I__RESULT_LINK:
      if (self->link != NULL)
        g_object_unref (self->link);
      self->link = g_value_dup_object (value);
      self->__isset_link = TRUE;
      break;

    case PROP_I__RESULT_SECOND:
      if (self->second != NULL)
        g_object_unref (self->second);
      self->second = g_value_dup_object (value);
      self->__isset_second = TRUE;
      break;

    case PROP_I__RESULT_SCHEMA:
      if (self->schema != NULL)
        g_object_unref (self->schema);
      self->schema = g_value_dup_object (value);
      self->__isset_schema = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__result_get_property (GObject *object,
                        guint property_id,
                        GValue *value,
                        GParamSpec *pspec)
{
  I_Result *self = I__RESULT (object);

  switch (property_id)
  {
    case PROP_I__RESULT_RETURN_ITEMS:
      g_value_set_int (value, self->return_items);
      break;

    case PROP_I__RESULT_FIRST:
      g_value_set_object (value, self->first);
      break;

    case PROP_I__RESULT_LINK:
      g_value_set_object (value, self->link);
      break;

    case PROP_I__RESULT_SECOND:
      g_value_set_object (value, self->second);
      break;

    case PROP_I__RESULT_SCHEMA:
      g_value_set_object (value, self->schema);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__result_instance_init (I_Result * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_return_items = FALSE;
  object->first = g_object_new (TYPE_I__NODE, NULL);
  object->__isset_first = FALSE;
  object->link = g_object_new (TYPE_I__LINK, NULL);
  object->__isset_link = FALSE;
  object->second = g_object_new (TYPE_I__NODE, NULL);
  object->__isset_second = FALSE;
  object->schema = g_object_new (TYPE_I__SCHEMA, NULL);
  object->__isset_schema = FALSE;
}

static void 
i__result_finalize (GObject *object)
{
  I_Result *tobject = I__RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->first != NULL)
  {
    g_object_unref(tobject->first);
    tobject->first = NULL;
  }
  if (tobject->link != NULL)
  {
    g_object_unref(tobject->link);
    tobject->link = NULL;
  }
  if (tobject->second != NULL)
  {
    g_object_unref(tobject->second);
    tobject->second = NULL;
  }
  if (tobject->schema != NULL)
  {
    g_object_unref(tobject->schema);
    tobject->schema = NULL;
  }
}

static void
i__result_class_init (I_ResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__result_read;
  struct_class->write = i__result_write;

  gobject_class->finalize = i__result_finalize;
  gobject_class->get_property = i__result_get_property;
  gobject_class->set_property = i__result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__RESULT_RETURN_ITEMS,
     g_param_spec_int ("return_items",
                       NULL,
                       NULL,
                       0,
                       8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__RESULT_FIRST,
     g_param_spec_object ("first",
                         NULL,
                         NULL,
                         TYPE_I__NODE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__RESULT_LINK,
     g_param_spec_object ("link",
                         NULL,
                         NULL,
                         TYPE_I__LINK,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__RESULT_SECOND,
     g_param_spec_object ("second",
                         NULL,
                         NULL,
                         TYPE_I__NODE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__RESULT_SCHEMA,
     g_param_spec_object ("schema",
                         NULL,
                         NULL,
                         TYPE_I__SCHEMA,
                         G_PARAM_READWRITE));
}

GType
i__result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_ResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_Result),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_ResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_uQueryResultProperties
{
  PROP_I_U_QUERY_RESULT_0,
  PROP_I_U_QUERY_RESULT_SCHEMA,
  PROP_I_U_QUERY_RESULT_ITEMS
};

/* reads a i_u_query_result object */
static gint32
i_u_query_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_uQueryResult * this_object = I_U_QUERY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->schema), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_schema = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              I_Result * _elem22 = NULL;
              if ( _elem22 != NULL)
              {
                g_object_unref (_elem22);
              }
              _elem22 = g_object_new (TYPE_I__RESULT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem22), protocol, error)) < 0)
              {
                g_object_unref (_elem22);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->items, _elem22);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_items = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_u_query_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_uQueryResult * this_object = I_U_QUERY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_uQueryResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_schema == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "schema", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->schema), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_items == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "items", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i23;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->items ? this_object->items->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i23 = 0; i23 < (this_object->items ? this_object->items->len : 0); i23++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->items, i23))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_u_query_result_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  I_uQueryResult *self = I_U_QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_I_U_QUERY_RESULT_SCHEMA:
      if (self->schema != NULL)
        g_object_unref (self->schema);
      self->schema = g_value_dup_object (value);
      self->__isset_schema = TRUE;
      break;

    case PROP_I_U_QUERY_RESULT_ITEMS:
      if (self->items != NULL)
        g_ptr_array_unref (self->items);
      self->items = g_value_dup_boxed (value);
      self->__isset_items = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_u_query_result_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  I_uQueryResult *self = I_U_QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_I_U_QUERY_RESULT_SCHEMA:
      g_value_set_object (value, self->schema);
      break;

    case PROP_I_U_QUERY_RESULT_ITEMS:
      g_value_set_boxed (value, self->items);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_u_query_result_instance_init (I_uQueryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->schema = g_object_new (TYPE_I__SCHEMA, NULL);
  object->__isset_schema = FALSE;
  object->items = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_items = FALSE;
}

static void 
i_u_query_result_finalize (GObject *object)
{
  I_uQueryResult *tobject = I_U_QUERY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->schema != NULL)
  {
    g_object_unref(tobject->schema);
    tobject->schema = NULL;
  }
  if (tobject->items != NULL)
  {
    g_ptr_array_unref (tobject->items);
    tobject->items = NULL;
  }
}

static void
i_u_query_result_class_init (I_uQueryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_u_query_result_read;
  struct_class->write = i_u_query_result_write;

  gobject_class->finalize = i_u_query_result_finalize;
  gobject_class->get_property = i_u_query_result_get_property;
  gobject_class->set_property = i_u_query_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_U_QUERY_RESULT_SCHEMA,
     g_param_spec_object ("schema",
                         NULL,
                         NULL,
                         TYPE_I__SCHEMA,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_U_QUERY_RESULT_ITEMS,
     g_param_spec_boxed ("items",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
i_u_query_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_uQueryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_u_query_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_uQueryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_u_query_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_uQueryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _I_QueryResultProperties
{
  PROP_I__QUERY_RESULT_0,
  PROP_I__QUERY_RESULT_TYPE,
  PROP_I__QUERY_RESULT_MESSAGE,
  PROP_I__QUERY_RESULT_RESULT
};

/* reads a i__query_result object */
static gint32
i__query_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  I_QueryResult * this_object = I__QUERY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast24;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast24, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (I_QueryResultType)ecast24;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->result), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_result = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i__query_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  I_QueryResult * this_object = I__QUERY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "I_QueryResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_result == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "result", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->result), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i__query_result_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  I_QueryResult *self = I__QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_I__QUERY_RESULT_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_I__QUERY_RESULT_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    case PROP_I__QUERY_RESULT_RESULT:
      if (self->result != NULL)
        g_object_unref (self->result);
      self->result = g_value_dup_object (value);
      self->__isset_result = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i__query_result_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  I_QueryResult *self = I__QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_I__QUERY_RESULT_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_I__QUERY_RESULT_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    case PROP_I__QUERY_RESULT_RESULT:
      g_value_set_object (value, self->result);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i__query_result_instance_init (I_QueryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->message = NULL;
  object->__isset_message = FALSE;
  object->result = g_object_new (TYPE_I_U_QUERY_RESULT, NULL);
  object->__isset_result = FALSE;
}

static void 
i__query_result_finalize (GObject *object)
{
  I_QueryResult *tobject = I__QUERY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
  if (tobject->result != NULL)
  {
    g_object_unref(tobject->result);
    tobject->result = NULL;
  }
}

static void
i__query_result_class_init (I_QueryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i__query_result_read;
  struct_class->write = i__query_result_write;

  gobject_class->finalize = i__query_result_finalize;
  gobject_class->get_property = i__query_result_get_property;
  gobject_class->set_property = i__query_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I__QUERY_RESULT_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       2,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__QUERY_RESULT_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I__QUERY_RESULT_RESULT,
     g_param_spec_object ("result",
                         NULL,
                         NULL,
                         TYPE_I_U_QUERY_RESULT,
                         G_PARAM_READWRITE));
}

GType
i__query_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (I_QueryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i__query_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (I_QueryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i__query_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "I_QueryResultType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

enum _querySvcExecuteArgsProperties
{
  PROP_QUERY_SVC_EXECUTE_ARGS_0,
  PROP_QUERY_SVC_EXECUTE_ARGS_QUERY
};

/* reads a query_svc_execute_args object */
static gint32
query_svc_execute_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  querySvcExecuteArgs * this_object = QUERY_SVC_EXECUTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
query_svc_execute_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  querySvcExecuteArgs * this_object = QUERY_SVC_EXECUTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "querySvcExecuteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "query", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->query), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
query_svc_execute_args_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  querySvcExecuteArgs *self = QUERY_SVC_EXECUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_QUERY_SVC_EXECUTE_ARGS_QUERY:
      if (self->query != NULL)
        g_object_unref (self->query);
      self->query = g_value_dup_object (value);
      self->__isset_query = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
query_svc_execute_args_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  querySvcExecuteArgs *self = QUERY_SVC_EXECUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_QUERY_SVC_EXECUTE_ARGS_QUERY:
      g_value_set_object (value, self->query);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
query_svc_execute_args_instance_init (querySvcExecuteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->query = g_object_new (TYPE_I__QUERY, NULL);
  object->__isset_query = FALSE;
}

static void 
query_svc_execute_args_finalize (GObject *object)
{
  querySvcExecuteArgs *tobject = QUERY_SVC_EXECUTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->query != NULL)
  {
    g_object_unref(tobject->query);
    tobject->query = NULL;
  }
}

static void
query_svc_execute_args_class_init (querySvcExecuteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = query_svc_execute_args_read;
  struct_class->write = query_svc_execute_args_write;

  gobject_class->finalize = query_svc_execute_args_finalize;
  gobject_class->get_property = query_svc_execute_args_get_property;
  gobject_class->set_property = query_svc_execute_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_QUERY_SVC_EXECUTE_ARGS_QUERY,
     g_param_spec_object ("query",
                         NULL,
                         NULL,
                         TYPE_I__QUERY,
                         G_PARAM_READWRITE));
}

GType
query_svc_execute_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (querySvcExecuteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) query_svc_execute_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (querySvcExecuteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) query_svc_execute_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "querySvcExecuteArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _querySvcExecuteResultProperties
{
  PROP_QUERY_SVC_EXECUTE_RESULT_0,
  PROP_QUERY_SVC_EXECUTE_RESULT_SUCCESS
};

/* reads a query_svc_execute_result object */
static gint32
query_svc_execute_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  querySvcExecuteResult * this_object = QUERY_SVC_EXECUTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
query_svc_execute_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  querySvcExecuteResult * this_object = QUERY_SVC_EXECUTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "querySvcExecuteResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
query_svc_execute_result_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  querySvcExecuteResult *self = QUERY_SVC_EXECUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_QUERY_SVC_EXECUTE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
query_svc_execute_result_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  querySvcExecuteResult *self = QUERY_SVC_EXECUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_QUERY_SVC_EXECUTE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
query_svc_execute_result_instance_init (querySvcExecuteResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_I__QUERY_RESULT, NULL);
  object->__isset_success = FALSE;
}

static void 
query_svc_execute_result_finalize (GObject *object)
{
  querySvcExecuteResult *tobject = QUERY_SVC_EXECUTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
query_svc_execute_result_class_init (querySvcExecuteResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = query_svc_execute_result_read;
  struct_class->write = query_svc_execute_result_write;

  gobject_class->finalize = query_svc_execute_result_finalize;
  gobject_class->get_property = query_svc_execute_result_get_property;
  gobject_class->set_property = query_svc_execute_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_QUERY_SVC_EXECUTE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_I__QUERY_RESULT,
                         G_PARAM_READWRITE));
}

GType
query_svc_execute_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (querySvcExecuteResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) query_svc_execute_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (querySvcExecuteResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) query_svc_execute_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "querySvcExecuteResultType",
                                   &type_info, 0);
  }

  return type;
}

